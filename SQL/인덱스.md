# SQL

## 10월 25일

### 인덱스

#### B-tree 인덱스
* 트리구조
* 가장많이 사용하는 인덱스
* 균형이 잘 잡혀져 있다.

#### 비트맵 인덱스
* 데이터를 비트 플래그로 변환해서 저장하는 형태의 인덱스
* 카디널리티(집합의 크기)가 낮은 필드에 대해 효과를 발휘
* 갱신할 때 오버헤드가 너무 크기 때문에 빈번한 갱신이 일어나지 않는 BI(Business Intelligence)/DWH(data warehouse) 용도로 사용됩니다.
* BI : 기업에서 데이터를 수집, 정리, 분석하고 활요하여 효율적인 의사 결정을 할 수 있는 방법에 대해 연구하는 학문
* DWH : 사용자의 의사 결정에 도움을 주기 위하여, 기간시스템의 데이터베이스에 축전된 데이터를 공통의 형식으로 변환해서 관리하는 데이터 베이스

#### 해시 인덱스
* 키를 해시 분산해서 등가 검색을 고속으로 실행하고자 만들어진 인덱스
* 등가 검색외에는 효과가 거의 없고 범위 검색을 할 수 없다는 점 때문에 거의 사용 되지 않는다.

#### B+tree
* B-tree의 수정버전
* 범용성이 좋다.
* 키값 사이에 검색 속도의 불균형이 거의 없으므로 데이터양이 증가해도 검색 속도가 갑자기 악화하는 일이 없다.
* 등호와 부등호 모두 사용가능

#### 인덱스 선택시 포인트
1.카디널리티(집합의 크기)와 선택률
  * 카디널리티가 높은 필드는 모든 레코드에 다른 값이 들어가 있는 유일 키 필드
  * 낮은 필드는 모든 레코드에 같은 값이 들어가 있는 동일한 키 필드
  * 클러스터링 팩터 : 저장소에서 데이터들이 물리적으로 뭉쳐있는지를 나타내는 개념. 높을수록 분산/낮을수록 뭉침

2.인덱스를 사용하는 것이 좋은지 판단
  * 카디널리티가 높고 선택률이 낮아야 한다.
  * DBMS에서 선택률이 5% ~ 10%일 경우 인덱스를 채택한다.


#### 인덱스를 사용 할 수 없는 경우
1.압축 조건이 존재하지 않음
<pre><code>
SELECT order_id, receive_date
FROM Orders;
(Full Scan을 하기 때문에 인덱스를 만들어도 사용 되지 않는다.)
</pre></code>

2.레코드를 제대로 압축하지 못하는 경우
<pre><code>
SELECT order_id, receive_date
FROM Orders
WHERE process_flg = ‘5’;
(특정 조건이더라도 만약 선택률이 85%가 나왔다고 가정하면 Full Scan보다 늘려 질 수가 있다.)


SELECT order_id, receive_date
FROM Orders
WHERE receive_date BETWEEN :start_date AND :end_date;
(입력 매개변수(date)에 따라 선택률이 변동되는 경우는 효율적이지 못하다.)
</pre></code>

3.인덱스를 사용하지 않는 검색 조건
<pre><code>
1.LIKE 연산자를 사용할 경우 ‘대공원%’ 이 경우에만 인덱스를 사용가능하다. 
SELECT order_id
	FROM Orders
	WHERE shop_name LIKE ‘%대공원%’;


2.색인 필드로 연산 할 경우에는 인덱스 사용 불가능
SELECT *
	FROM SomeTable	
	WHERE col_1 * 1.1 > 100;


3.검색 조건의 우변에 식을 사용할 때는 인덱스 사용 가능
SELECT *
	FROM SomeTable	
	WHERE col_1 > 100/1.1;


4.색인 필드에는 NULL이라는 값이 존재하지 않기 때문에(IS NULL)
SELECT *
	FROM SomeTable
	WHERE col_1 IS NULL;


5.인덱스 내부에 필드에는 값이 존재하는거지 함수(연산)이 존재하는게 아니기 때문에(함수 사용)
SELECT *
	FROM SomeTable
	WHERE LENGTH(col_1) = 10;


6.부정형을 사용하는 경우(부정형)
SELECT *
	FROM SomeTable
	WHERE col_1 <> 10;
</pre></code>

#### 인덱스를 사용 할 수 없는 경우 대처법
1. 어플리케이션에서의 설정으로 처리 -> ex)어플리케이션 UI에서 제한적으로 선택하게 하자(날짜기간 한달/점포ID&주문일자)
2. 인덱스 온리 스캔 -> ex)테이블에 두개의 필드만 존재 할 경우 두개의 필드로 구성된 인덱스를 만들어 테이블에 접근하지 않게 할 수 있다.(I/O비용이 줄어든다)
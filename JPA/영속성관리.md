# JPA

## 11월 14일

### 영속성 관리

#### ORM

#### JPA
* 자바진영의 ORM 표준 API(인터페이스)

#### Hibernate
* JPA 구현체

#### 엔티티 매니저 팩토리
* 생성 비용이 매우크다
* 하나만 생성하자
* 여러 스레드가 동시에 접근해도 안전하다

#### 엔티니 매니저
* 생성 비용이 적다
* 여러개 생성 가능
* 여러 스레드가 동시에 접근하면 안된다(동시성 문제가 발생/공유 X)

#### 영속성 컨텍스트
* 엔티티를 영구 저장하는 환경
* 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티니 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
<pre><code>
em.persist(member);//엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다.
</code></pre>

#### 엔티티의 생명주기
* 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
* 영속(managed) : 영속성 컨텍스트에 저장된 상태
* 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
* 삭제(removed) : 삭제된 상태

#### 비영속
* 엔티티 객체를 생성, 순순한 객체 상태이며 아직 저장하지 않은 상태
<pre><code>
//객체를 생성한 상태(비영속)
Member member = new Member();
member.setId(“member1”);
member.setUsename(“회원”);
</code></pre>

#### 영속
* 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스테에 저장한다.
* 영속성 컨텍스트가 관리하는 엔티티를 영속 상태
* 영속상태란 - 영속석 컨텍스트에 의해 관리된다는 것
<pre><code>
//객체를 저장한 상태(영속)
em.persist(member);
</code></pre>

#### 준영속
* 영속성 컨텍스트가 관리하던 영속 상태의 언티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태
<pre><code>
//회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
em.detach(member); 
em.close(); //영속성 컨텍스트 닫기
em.clear(); //영속성 컨텍스트 초기화
</code></pre>

#### 삭제
* 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제
<pre><code>
//객체를 삭제한 상태(삭제)
em.remove(member);
</code></pre>

#### 영속성 컨텍스트와 식별자 값
* 엔티티를 식별자값(@Id)로 구분
* 영속 상태는 식별자 값이 반드시 있어야한다(오류남)

#### 플러시(flush)
* 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영

#### 영속성 컨텍스트의 장점
* 1차캐시 - 영속성 컨텍스트에 저장된 엔티티를 조회 없으면 데이터베이스에서 조회
* 동일성 보장 - 식별자가 같은 엔티티를 조회해서 다른변수에 담아도 ==(같은객체)로 인식
* 트랜잭션을 지원하는 쓰기 지연 - 트랜잭션을 이용하여 연속적인 엔티티개체를 추가하게 된다면
* 영속성컨텍스트에 1차캐시로 엔티티개체를 생성하고 데이터베이스에 보낼 SQL문은 쓰기지연SQL저장소에 저장되어 있다가 트랜잭션.커밋을 하게되면 데이터베이스로 SQL문이 보내진다.(함께 저장하고 롤백하기위해)
* 변경 감지 - 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능(SQL에 의존적 개발X / 스냅샷과 비교 : 최초의 상태를 복사해서 저장)
* 지연 로딩

#### 변경감지
* 모든 필드를 사용하여 데이터베이스에 UPDATE 쿼리를 날린다.
* 데이터가 많을경우 동적으로 만들어주는 어노테이션을 사용하자
* 모든 필드를 사용하여 UPDATE쿼리를 날리면 수정쿼리는 항상같다.(미리 생성해두고 재사용가능)
* 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리르 재사용

#### 플러시
* 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
* 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것
* 스냅샷과 비교하여 엔티티 변경사항 파악
* 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

#### 플러시 호출 방법
* em.flush() - 테스트사용시/거의 사용하지않음
* 트랜잭션 커밋시 - JPA가 트랜잭션시 사용시 호출하게 해줌
* JPQL 쿼리 실행시 - JPQL은 SQL로 데이터베이스를 조회해야하지만 아직 데이터베이스에 변경사항이 적용되어 있지않으면 쿼리가 제대로 실행 되지 않을수 있기 때문에 쿼리 실행 직전에 플러시가 호출됨

#### 지연로딩
* 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법

#### 병합
* 준영속 상태의 엔티티를 다시 영속 상태로 변경해준다.
<pre><code>
Mebmer mergeMebmer = em.merge(member);
</code></pre>
# SPRING-BOOT

## 11월 22일

### 서버 아키텍쳐

#### Monolithic Architecture
* 하나의 애플리케이션 내에 모든 로직들이 모두 들어가는 “통짜구조”이다.
* 예) 온라인 쇼핑몰 애플리케이션이 있을 때, 톰캣 서버에서 도는 WAR 파일(웹 애플리케이션 패키징 파일)내에, 사용자 관리, 상품, 주문 관리 모든 컴포넌트들이 들어 있고 이를 처리하는 UX 로직까지 하나로 포장되서 들어가 있는 구조이다.
* 장점 : 하나로 처리하기 때문에, 개발툴 등에서 하나의 애플리케이션만 개발, 배포 간편, 테스트 간편
* 단점 : 규모가 큰 애플리케이션에서 불리, 빌드 및 배포 시간, 서버의 기동시간, 특정 컴포넌트 수정시 전체 애플리케이션을 재 컴파일 실행, 컴포넌트별로 다른기술 도입 확장이 어렵다.

* * *

#### Service Oriented Architecture
* 기존의 애플리케이션의 기능들을 비즈니스적인 의미를 가지는 기능 단위로 묶어서 표준화된 호출 인터페이스를 통해서 서비스로 구현하고, 이 서비스들을 기업에 따라 조합하여 애플리케이션을 구성하는 소프트웨어 개발 아키텍쳐

* * *

#### Micro Service Architecture
* SOA가 근간이 되는 아키텍쳐
* 대용량 웹서비스 개발에 맞는 구조로 사상이 경량화 되고, 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍쳐

##### 서비스
* 사용자관리, 상품 관리, 주문 관리 같은 각 업무 별로 서비스를 나눠서 정의한다.

##### 구조
* 애플리케이션 로직을 분리해서 여러개의 애플리케이션으로 나눠서 서비스화, 각 서비스별로 서버를 분산 배치하는 것이 핵심

##### 데이타 분리
* 하나의 통 데이터 베이스를 사용하는 것이 아니라 서비스 별로 별도의 데이타 베이스를 사용
* 다른 컴포넌트의 데이타를 API 통신을 통해서만 가지고 와야 하기 때문에 성능상 문제를 야기 할 수 있고, 또한 이 기종 데이타 베이스간의 트랜잭션을 묶을 수 없는 문제점을 가지고 있다.

##### API Gateway
* 마치 프록시 서버 처럼 API를 앞에서 모든 API에 대한 End Point를 통합하고, 몇가지 추가적인 기능을 제공하는 미들웨어이다. 
* EndPoint 통합 및 토폴리지 정리 : 마이크로 서비스 아키텍쳐의 문제점 중의 하나는 각 서비스가 다른 서버에 분리 배포 되기 때문에, API의 End Point 즉, 서버의 URL이 각기 다르다는 것이다.
* Orchestration : 여러개의 서비스를 조합해서 새로운 서비스를 만들 수 있다. 포인트 적립과 물품 구매라는 서비스를 조합해서 물품 구입시 포인트 적립이라는 새로운 서비스를 만들어 낼 수 있다.
* 공통 기능 처리 : API에 대한 인증, Logging과 같은 공통 기능에 대해서 서비스 컴포넌트 별로 중복 개발해야 하는 비효율성을 유발, API Gateway로 이러한 문제점을 처리 가능하다.
* 배포 : 유연한 배포 모델, 서비스 부분만 배포가 가능, 시스템 영향을 최소화
* 확장성 : 부하가 많은 특정 서비스에 대해서만 확장이 가능하여 조금 더 유연한 확장 모델을 가질 수 있다. 부하가 많은 컴포넌트만 확장을 하면 된다.

##### 성능
* 서비스 서버간의 통신의 자원(시간, 변환 로직)이 소비 된다.

##### 메모리
* 각서비스마다 중보되는 모듈이 생김(예: 스프링으로 개발시 스프링 의존성들이 각서비스마다 중복)

##### 테스팅이 어려움
* 서비스간의 의존성이 있을 경우 서버간의 통신을 하면 테스트 해야하기 때문에 환경 구축이나 문제 발생시 분리된 여러개의 시스템을 동시에 봐야하기 때문에 테스팅의 복잡도가 올라간다.

##### 서비스간 트랜잭션 처리
* API 기반의 여러 서비스를 하나의 트랜잭션으로 묶는 것은 불가능하다.
* 해결 방안
  1. 분산 트랜잭션처리를 없애 버린다. 트랜잭션 처리를 모노리틱 아키텍쳐를 이용하여 처리
  2. 보상 트랜잭션 처리(에러 처리 로직을 구현)
  3. 복합서비스(분산 트랜잭션 프로토콜을 사용)

# 자바 병렬 프로그래밍

## 3월 17일

### 1.개요

#### 개요
- 프로그램을 제대로 돌아가게 작성하는 일은 어렵다. 하지만 여러 작업을 동시에 실행하는 프로그램을 제대로 돌아가게 작성하기는 훨씬 더 어렵다.
- 여러 작업을 동시에 실행하는 프로그램은 순차적으로 실행하는 프로그램보다 오류 발생 가능성이 높다.
- 스레드는 자바 언어에서 필할 수 없는 특성이고, 복잡한 비동기 코드를 더 단순한 순차적 코드로 바꿔 복잡한 시스템을 단순하게 개발할 수 있게 해준다.
- 스레드는 멀티프로세서 시스템의 능력을 최대한 끌어낼 수 있는 가장 쉬운 방법이다.

#### 간략한 역사
- 초창기에는 컴퓨터에 운영체제 자체가 없었다.
- 운영체제 없이 하드웨어 위에서 바로 실행되는 프로그램은 작성하기도 힘들었을 뿐 아니라 한 번에 프로그램 하나만 실행하느라 그 비싼 컴퓨터 자원을 드문드문 사용하기 때문에 자원 대비 성능은 상당히 비효율적이었다.
- 운영체제는 여러 개의 프로그램을 각자의 프로세스 내에서 동시에 실행할 수 있도록 발전됐다.
- 프로세스는 각자가 서로 격리된 채로 독립적으로 실행되는 프로그램으로서 운영체제는 프로세스마다 메모리, 파일 핸들, 보안 권한 등의 자원을 할당한다.
- 프로세스끼리는 서로 통신을 할 수도 있는데 소켓, 시그널 핸들러 ,공유 메모리, 세마포어, 파일 등의 비교적 큰 단위의 다양한 통신 수단이 제공된다.
- 여러 프로그램을 동시에 실행할 수 있는 운영체제를 개발하게 된 몇 가지 요인
    - 자원 활용
        - 프로그램은 때로 입출력과 같이 외부 동작이 끝나기를 기다려야 하는 경우가 많은데 기다리는 동안은 유용한 일을 처리하지 못한다.
        - 따라서 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적이다.
    - 공정성
        - 여러 사용자와 프로그램이 컴퓨터 내 자원에 대해 동일한 권한을 가질 수 있다.
        - 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하는 것보다는 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직하다.
    - 편의성
        - 때로 여러 작업을 전부 처리하는 프로그램 하나를 작성하는 것보다는 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직하다.
- 초기 시분할 시스템
    - 각각 명령어와 데이터를 저장하는 메모리 공간을 가지고 기계어로 된 명령어를 순차적으로 수행하며, 운영체제가 제공하는 I/O 수단을 통해 컴퓨터 외부와 교류 했다.
    - 각 명령어 마다 다음 명령이 명료하게 정의되어 있었고, 명령어 집합의 규칙에 따라 실행 흐름이 제어 됐다.
    - 현재 널리 사용되는 대부분의 프로그램 언어가 순차적 프로그래밍 방식을 따른다.
- 순차적 프로그래밍 모델
    - 사람이 생각하는 방식과 같아서 직관적이고 자연스럽다.
- 스레드
    - 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안됐다.
    - 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어 흐름이 공존할 수 있다.
    - 스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유한다.
    - 하지만 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 갖는다.
    - 즉 한 프로그램 내 여러 스레드를 동시에 여러 개의 CPU에 할당해 실행시킬 수 있다.
    - 스레드는 가벼운 프로세스라고 부르기도 하며, 현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 정한다.
    - 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유한다.(한 프로세스 내 모든 스레드는 같은 힙에 객체를 할당)
    - 프로세스 때보다 더 세밀한 단위로 데이터를 공유할 수 있다.
    - 하지만 공유된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수도 있다.

#### 스레드의 이점
- 스레드를 제대로만 사용하면 개발 및 유지 보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있다.
- 비동기적인 일 흐름을 거의 순차적으로 바꿀 수 있어 사람이 일하고 상호 작용하는 방식을 모델링하기 쉬워진다.
- 코드를 새로 작성해 읽기 쉽고 유지 보수하기도 쉬운 명료한 코드로 만들 수도 있다.
- 서버 애플리케이션에 자원 활용도와 처리율을 높이는 데 유용하다.
- GUI 애플리케이션에서 사용자 인터페이스가 더 빨리 반응하게 만들수 있다.
- JVM을 더 단순하게 구현할 수 있도록 도와준다.(가비지 컬렉터)
- 아주 단순한 자바 애플리케이션이 아닌 이상 어느 정도는 여러 개의 스레드를 사용한다.

#### 스레드의 이점 - 멀티프로세서 활용
- 프로세서 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다.
- 활성 상태인 스레드가 여러 개인 프로그램은 여러 프로세서에서 동시에 실행될 수 있다.
- 제대로 설계하기만 한다면 멀티스레드 프로그램은 가용한 프로세서 자원을 더 효율적으로 이용해서 처리 속도를 높일 수 있다.
- 여러 개의 스레드를 사용하면 프로세서가 하나라 해도 처리 속도를 높일 수 있다.
- I/O 때문에 대기 상태에 들어가는 동안에도 다른 스레드는 동작할 수 있기 때문에 애플리케이션이 계속 실행된다.

#### 스레드의 이점 - 단순한 모델링
- 보통 여러 종류의 일을 처리해야 할 때보다 한 종류의 작업 여러 개를 처리하는 경우가 훨씬 쉽다.
- 한 종류 일을 순차적으로 처리하는 프로그램은 작성하기 쉽고 오류도 별로 생기지 않는다.
- 또 여러 종류의 일을 동시에 처리하는 프로그램보다 테스트하기도 쉽다.
- 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.
- 이런 작업 흐름에서는 특정한 동기화 시점에서만 상호 작용이 발생한다.
- 이런 장점은 서블릿, RMI와 같은 프레임웍에서 종종 활용된다.
- 프레임웍은 요청 관리, 스레드 생성, 로드 밸런싱, 그리고 작업 흐름 내에서 적절한 시점에 적절한 애플리케이션 컴포너는에게 요청을 분배하는 등의 상세한 부분을 처리한다.
- 서블릇 개발자는 동시에 다른 요청이 얼마나 많이 처리되고 있는지, 소켓 입출력 스트림이 대기 상태에 들어갔는지에 대해서는 걱정할 필요가 없다.
- 웹 요청이 들어와서 서블릿의 service 메소드가 호출될 때 해당 요청을 마치 단일 스레드 프로그램인 것처럼 처리할 수 있다. 이 때문에 컴포너는 개발 작업이 훨씬 단순해지고 프레임웍을 쉽게 익힐 수 있다.

#### 스레드의 이점 - 단순한 비동기 이벤트 처리
- 여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워진다.
- 읽을 데이터가 없을 때 소켓에서 읽으려고 하면 애플리케이션은 추가 데이터가 들어올 때까지 read 연산에서 대기한다. 이때 스레드가 하나뿐이라면 해당 요청에 대한 작업이 멈추는 것 뿐만 아니라 다른 모든 요청도 처리하지 못하고 멈춘다.
- 이러한 문제를 피하려면 넌블로킹 I/O 기능을 써야만 한다. 하지만 각 요청을 별개 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는 데는 별 영향을 끼치지 않는다.

#### 스레드의 이점 - 더 빨리 반응하는 사용자 인터페이스
- 대부분 GUI 프레임워크는 단일 스레드로 움직이도록 구현되어 있다.
- 따라서 사실상 메인 이벤트 루프가 여전히 남아있기는 하지만, 별도 스레드에서 애플리케이션이 아닌 GUI 툴킷 관할하에 실행된다.
- 이벤트 스레드에서 상대적으로 오래 걸리는 작업을 싱행하면 반응 속도가 떨어진다.
- 하지만 이런 경우에 시간이 오래 걸릴 작업을 별도 스레드에서 실행했다면 이벤트 스레드는 계속 UI 이벤트를 처리할 수 있어 UI가 더 빨리 반응했을 것이다.

#### 스레드 사용의 위험성
- 자바 자체에 스레드 관련 기능이 내장되어 있다는 점은 어떻게 보면 양날의 칼이라고 할 수 있다.
- 언어 및 라이브러리 측면에서의 스레드 지원과 플랫폼 독립적으로 정형화된 메모리 모델 때문에 병렬 프로그램을 개발하는 일이 쉽긴 하지만, 스레드를 사용해 작성하는 프로그램이 더 많아졌기 때문에 개발자에 대한 기대치도 높아지는 경향이 있다.
- 개발자라면 대부분 스레드 안전성에 대해 잘 알아야 한다.

#### 스레드 사용의 위험성 - 안전성 위해 요소
- 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서가 때론 놀라울 만큼 예측하기가 어렵다.
- 스레드가 하나일 때는 아무런 문제가 없다. 하지만 스레드가 여럿일 때는 제대로 동작하지 않는다.
<pre><code>
//스레드가 안전하지 않은 일련번호 생성
@NotThreadSafe
public class UnsafeSequnece {
	private int value;

	public int getNext() {
		return value++;
	}
} 

//스레드가 안전한 일련번호 생성
@ThreadSafe
public class Sequnece {
	@GuardeBy(“this”) private int value;

	public synchronized int getNext() {
		return value++;
	}
} 
</code></pre>
- 스레드 안전성을 문서화하는 어노테이션은 여러 사람에게 모두 유용하다.
- 만약 @ThreadSafe라고 표시하면 클래스를 사용하는 사람은 멀티스레드 환경에서 문제가 없다는 점을 명확히 알 수 있고, 유지 보수하는 개발자는 스레드 안전성이 계속 보장돼야 한다는 점에 주의할 수 있다.
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있다.
- 이는 상당히 편리한데, 다른 스레드 간 통신 방식보다 데이터 공유가 훨씬 쉽기 때문이다. 하지만 이점은 위험 요소기도 하다.
- 즉 데이터가 예측 못한 시점에 변경돼 스레드가 혼동될 수도 있다.
- 멀티스레드 프로그램이 동작하는 모습을 예측하려면 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야 한다. 다행히 자바에서는 공유 변수 접근을 조율하기 위한 동기화 수단이 제공된다.
- 동기화를 하지 않으면 컴파일러, 하드웨어, 실행 환경 각각에서 명령어의 실행 시점이나 실행 순서를 상당히 자유롭게 조장할 수 있다. 보이지 않는 프로세서별 캐시 메모리에 변수를 캐시해둘 수도 있다.
- 하지만 프로그래머 입장에선 이런 최적화 작업 때문에 프로그램에 오류가 발생하지 않도록 스레드 간에 데이터가 공유되고 있는지를 명확하게 구분해 줘야 하는 부담을 떠 안아야 한다.

#### 스레드 사용의 위험성 - 활동성 위험
- 동시 수행 코드를 개발할 때는 반드시 스레드 안전성 문제를 신경 써야 한다.
- 즉 안전성은 양보할 수 없다. 안전성이 중요한 것은 멀티스레드 프로그램만이 아니다.
- 단일 스레드 프로그램도 안전성과 정확성을 유지하도록 작성돼야 한다.
- 멀티스레드 프로그램에서는 단일 스레드 프로그램에서 나타나지 않는 추가적인 형태의 활동성 장애가 생길수 있다.
- 안전성
    - 잘못된 일이 생기지 않는다.
- 활동성
    - 원하는 일이 결국 일어난다.
- 활동성 장애
    - 어떤 작업이 전혀 진전되지 못하는 상태에 빠질 때 활동성 장애가 발생했다고 한다.
    - ex) 순차적 프로그램 - 무한루프, 멀티 쓰레드 - 데드락, 소모상태, 라이브락 등
    - 활동성 장애를 일으키는 오류 역시 초기에 파악하기가 무척 어렵다.
    - 개발이나 테스트 도중에 잘드러나지 않는다(다중 스레드 환경에서 타이밍에 따라 활동성 문제점이 발생하기 때문에)

#### 스레드 사용의 위험성 - 성능 위험
- 활동성은 뭔가 좋은 일이 반드시 일어난다는 것을 뜻한다.
- 성능 문제는 형편없는 서비스 시간, 반응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄한다.
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있다.
- 하지만 스레드를 사용하면 실행 중에 어느 정도 부하가 생기는 것도 사실이다.
- 스레드가 많은 프로그램에서는 컨텍스트 스위칭이 더 빈번하고, 그 때문에 상당한 부담이 생긴다.
- 또 스레드가 데이터를 공유할 때는 동기화 수단도 사용해야 한다. 이런 동기화는 컴파일러 최적화를 방해하고, 메모리 캐시를 지우거나 무효화하기도 한다.
- 그 밖에 공유 메모리 버스에 동기화 관련 트래픽을 유발한다.

#### 스레드는 어디에나
- 스레드에 안전한 클래스를 개발할 때는 더 세심하게 주의하고 분석해야 하며, 이런 면은 개발자 입장에서 볼 때 설계와 구현 어는 부분에서도 상당한 부담이 된다.
- 모든 자바 프로그램은 기본적으로 스레드를 사용한다. 
    - JVM을 시작시키면 메소드를 실행할 주 스레드, 가비지 컬렉션, 객체 종료와 같은 JVM 내부 작업을 담당할 스레드도 생성
    - 사용자 인터페이스 프레임웍은 사용자 인터페이스의 이벤트를 관리할 스레드 생성
    - 서블릿이나 RMI 같은 컴포넌트 프레임웍은 스레드를 관리하는 풀을 여러 개 생성하고 이 스레드를 사용해 컴포넌트의 메서드를 호출한다.
- 거의 모든 자바 프로그램이 멀티스레드로 동작하는 프로그램이고, 외부에서 프로그램 내부의 상태 접근하는 과정을 적절히 조율하지 않아도 될 만큼의 기본적인 조율 기능을 프레임웍이 담당해 주지는 않는다.
- 외부의 편의 수단 자체가 먼저 스레드에 안전해야겠지만 그것으로 충분하지는 않다. 스레드에 안전해야 한다는 필요성은 프로그램 전체로 퍼져 나간다.

#### 프레임웍과 프로그램 컴포넌트
- 프레임웍은 포로그램 컴포넌트를 호출할 때 프레임웍 내부의 스레드에서 호출하기 때문에 자동으로 프로그램이 스레드를 활용하는 것과 동일한 효과를 준다.
- 컴포넌트는 언제나 프레그램 내부의 상태를 접하기 때문에 해당 상태에 접근하는 모든 코드 경로에 해당하는 컴포넌트 역시 스레드 안전해야 한다.

#### 외부 편의 수단 - 타이머
- Timer는 추후에 한 번 혹은 주기적으로 실행될 작업을 스케줄하기 위한 편의 수단이다.
- Timer를 사용하면 TimerTask에 지정된 작업이 프로그램이 아닌 Timer가 관리하는 스레드에서 실행되기 때문에 순차적인 프로그램을 복잡하게 만들 수도 있다.
- TimerTask가 접근하는 객체 자체를 스레드에 안전하게 만드는 것이다.

#### 외부 편의 수단 - 서블릿과 JSP
- 서블릿 프레임웍은 웹 애플리케이션을 배치하고 원격 HTTP 클라이언트에서 오는 요청을 분배하기 위한 모든 기본 기능을 감당하도록 설계되어 있다.
- 서블릿명세에 따르면 서블릿은 여러 스레드에서 동시에 호출될 수 있게 작성돼야 한다. 다시 말해 서블릿은 스레드에 안전해야 한다.
- 서블릿이 서블릿 간 혹은 요청들에 간에 공유되는 객체에 접근할 때는 적절한 동기화 작업이 필요하다. 여러 요청 내에서 각기 다른 스레드로 동시에 접근하고 있을 수도 있기 때문이다.

#### 외부 편의 수단 - 원격 메소드 호출
- RMI는 다른 JVM에서 실행 중인 객체의 메소드를 호출할 수 있게 해준다. RMI로 원격 메소드를 호출하면, 메소드 인자는 바이트 스트림으로 변환되고 네트워크를 통해 원격 JVM으로 전달된다. 원격 JVM에서는 원래대로 변환되어 원격 메소드에 인자로 전달된다.
- 서블릿처럼 RMI 객체도 동시에 여러 번 호출될 수 있게 작성돼야 하며 스레드에 안전해야 한다.

#### 외부 편의 수단 - 스윙과 AWT
- GUI 애플리케이션은 본질적으로 비동기적으로 동작한다. 사용자는 언제든지 메뉴를 선택하고 버튼을 누를 수 있다.
- 또 애플리케이션이 다른 일을 하는 도중에도 즉각 반응하길 원한다. 이때문에 스윙과 AWT는 사용자가 발생시킨 이벤트를 처리하거나 사용자가 보는 그래픽을 갱신하기 위해 별도 스레드를 생성해 작업을 맡긴다.

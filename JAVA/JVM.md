# JAVA

## 4월 16일

### JVM

#### HOTSPOT VM구조
- JVM 엔진의 한종류
- SUN사가 만든 JVM 엔진
- JIT(JUST IN TIME) 컴파일러 => 자주 사용되는 부분을 바이트코드에서 기계코드로 변환시켜 빠른 속도로 실행하게 해준다.(최적화 *계속해서 JIT컴파일러가 컴파일을 시키지 않는다 => 컴파일이 자주 되면 성능 저하)
- VM 런타임(인터프리터 해석), JIT 컴파일러, 메모리 관리자
- GC(Garbage Collector)와 JIT컴파일러를 끼워 맞춰 사용 할 수있다.
- 거의 대부분 사람들이 HOTSPOT JVM을 사용 중

#### JIT Optimizer
- 자바의 경우 자바컴파일러가 자바소스를 class(바이트코드)로 변환 시키고 JVM에 의해서 인터프리터(변환된 바이트코드를 한줄씩 읽고 실행(컴파일x)!) 방식으로 실행이 된다.
- JIT 컴파일러는 이때 자주 사용되는 부분(메소드)를 바이트코드에서 기계코드로 변환시켜준다.(기계코드로 변환시 바이트코드보다 빠르게 동작할 수 있다. *로우레벨)
- 수행카운터(메소드가 수행될때마다 증가), 백에지 카운터(메서드가 루프가 존재하는지 확인)를 이용하여 컴파일 대상을 판단한다.
- 인터프리터가 카운트로 체크 하여 JIT컴파일러에게 컴파일을 요청한다.
- 백에지 카운터 계산법(자바성능튜닝이야기 참고)
- 컴파일 요청이 되면 큐에 쌓이고, 하나 이상의 컴파일러 쓰레드가 이 큐를 모니터링한다.
- 컴파일 종료되면 컴파일된 코드로 동작을 수행한다.
- OSR : 컴파일된 코드가 계속 수행중일때 최적화가 되지 않는다고 판단 되면 다시 컴파일을 시킨다.

#### JVM 종류
- HOTSPOT JVM, JRockIT JVM, IBM JVM

#### JRockIT JVM
- JRockit runs JIT Compilation, JRockit monitors threads, JRockit JVM Runs Optimization
- 인터프리터가 수행 될때마다 JIT COMPILER가 컴파일을 수행한다.
- 처음부터 컴파일 하기때문에 다른 JVM보다 속도가 느릴수 있다. 하지만 계속 실행을 할 수록 컴파일된 코드가 많아지므로 빨라진다.(*모든 메서드를 컴파일 하지는 않는다. 최적화 문제)
- 모니터링 스레드를 두어 어느 메소드가 많이 호출되는지 체크
- 스레드가 체크한 대상을 최적화 시켜준다.(인라이닝 : 메소드가 단순할때 적용되는 방식, b.getValue() -> b.value)

#### IBM JVM
- 인라이닝, 지역 최적화, 조건 구문 최적화, 글로벌 최적화, 네이티브 코드 최적화
- 인라이닝 : 자주 호출 메소드가 단순 할 경우 메소드의 코드로 변환 하여 최적화
- 지역 최적화 : 작은 단위의 코드를 분석하 개선하는 작업
- 조건 구문 최적화 : 조건 구문을 최적화 하고, 효율성을 위해서 코드의 수행 경로를 변경
- 글로벌 최적화 : 메소드 전체를 최적화하는 방식, 매우 비싼 방식, 긴 컴파일 시간이 단점, 장점으로는 성능 개선 많이 된다.
- 네이티브 코드 최적화 : 플랫폼의 아키텍처에 따라서 최적화 방식이 바뀐다.

#### 코드 캐시
- JIT으로 컴파일 된 소스가 JVM 프로세스 영역에 저장된다. (JVM 수행파일 + JIT 코드로 구성)

#### JVM 시작 절차
- 자바성능튜닝이야기 책 참조(P.308)

#### JVM 종료 절차
- 자바성능튜닝이야기 책 참조(P.311)
- kill -9 와 같은 명령어 사용시 정상적인 절차로 종료가 되지 않는다.

#### 클래스 로더
- 보다 빠른 JVM의 시작을 위해서 클라이언트 HotSpot VM은 '클래스 데이터 공유'라고 불리는 기능을 통해서 클래스를 미리 로딩 할 수 있다.

#### 예외처리
- 예외를 처리 가능한 핸들러를 찾아 자바 코드를 수행한다.
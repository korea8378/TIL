# HTTP 완벽 가이드

## 5월 4일

### 14장 보안 HTTP

#### 개요
-	트랜잭션을 보호하는 법을 알아보자
-	디지털 암호화를 이용해 도청이나 위조로부터 HTTP 트랜잭션을 안전하게 보호하는 더 복잡하고 적극적인 기술을 제시한다.

#### HTTP를 안전하게 만들기
-	사람들은 웹 트랜잭션을 중요한 일에 사용한다. 강력한 보안이 없다면, 사람들은 온라인 쇼핑이나 인터넷 뱅킹을 할 때 안심할 수 없을 것이다.	-	제한된 접근이 가능하지 않다면, 회사들은 중요한 문서를 웹 서버에 올려놓을 수 없을 것이다. 웹은 안전한 방식의 HTTP를 필요로 한다.
-	HTTP의 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 한다.
-	서버 인증
	-	클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
-	클라이언트 인증
	-	서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
-	무결성
	-	클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
-	암호화
	-	클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
-	효율
	-	저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
-	편재성
	-	프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
-	관리상 확장성
	-	누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
-	적응성
	-	현재 알려진 최선의 보안 방법을 지원해야 한다.
-	사회적 생존성
	-	사회의 문화적, 정치적 요구를 만족시켜야 한다.

#### HTTPS
-	HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다.
-	넷스케이프 커뮤니케이션 주식회사에서 개척하였으며 모든 주류 브라우저와 서버에서 지원한다.
-	HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.
-	HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하는데, 이 보안 계층은 안전 소켓 계층(SSL) 혹은 그를 계승한 전송 계층 보안(TLS)을 이용하여 구현된다.
-	어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다.
-	TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 된다.

#### 디지털 암호학
-	SSL과 HTTPS에서 이용되는 암호 인코딩 기법에 대해 약간의 배경 지식을 제공할 가질 필요가 있다.
-	암호
	-	텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
-	키
	-	암호의 동작을 변경하는 숫자로 된 매개변수
-	대칭키 암호 체계
	-	인코딩과 디코딩에 같은 키를 사용하는 알고리즘
-	비대칭키 암호 체계
	-	인코딩과 디코딩에 다른 키를 사용하는 알고리즘
-	공개키 암호법
	-	비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
-	디지털 서명
	-	메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
-	디지털 인증서
	-	신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

#### 디지털 암호학 - 비밀 코드의 기술과 과학
-	암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술이다.
-	암호법은 단순히 참견쟁이들이 볼 수 없도록 메시지를 암호화하는 것뿐 아니라, 메시지의 변조를 방지하기 위해 사용할 수도 있다.
-	어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용될 수 있다.

#### 디지털 암호학 - 암호
-	암호법은 암호라 불리는 비밀 코드에 기반한다.
-	암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.

#### 디지털 암호학 - 암호 기계
-	암호는 상대적으로 간단한 알고리즘으로 시작했는데, 사람이 직접 인코딩하고 디코딩해야 했기 때문이다.
-	기술이 진보하면서, 사람들은 보다 복잡한 암호로 메시지를 빠르고 정확하게 인코딩하고 디코딩하는 기계를 만들기 시작했다.
-	암호 기계는 암호를 깨뜨리기 어렵게 하기 위해, 단순히 회전을 하는 대신 글자들을 대체하고, 그 순서를 바꾸었으며, 메시지를 자르고 토막내었다.

#### 디지털 암호학 - 키가 있는 암호
-	코드 알고리즘과 기계가 적에 손에 들어갈 수 있기 때문에, 대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 잇는 다이얼이 달려있다.
-	누군가 기계를 훔치더라도, 올바른 다이얼 설정이 없이는 디코더가 동작하지 않을 것이다.
-	이러한 암호 매개변수를 키라고 부른다. 
-	암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다.
-	오늘날 거의 대부분의 암호 알고리즘은 키를 사용한다.

#### 디지털 암호학 - 디지털 암호
-	속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
-	매우 큰 키를 지원하는 것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다.
-	키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워진다.

#### 대칭키 암호법
-	많은 디지털 암호 알고리즘은 대칭키 암호라 불리는데, 왜냐하면 그들이 인코딩을 할 때 사용하는 키가 디코딩을 할 때와 같기 때문이다.
-	대칭키 암호에서, 발송자와 수신자 모두 통신을 위해 비밀 키 k를 똑같이 공유할 필요가 있다.

#### 대칭키 암호법 - 키 길이와 열거 공격
-	비밀 키가 누설되면 안 된다는 것은 매우 중요하다. 대부분의 경우, 인코딩 및 디코딩 알고리즘은 공객적으로 알려져 있으므로, 키만이 유일한 비밀이다.
-	무차별로 모든 키 값을 대입해보는 공격을 열거 공격이라고 한다.
-	만약 가능한 키 값이 아주 많다면, 악당은 암호를 깨뜨릴 수 있는 값 하나를 찾기 위해 수일이나 수년, 심지어는 우주의 수명만큼의 시간을 들여야 할 것이다.
-	가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려 있다.
-	40비트 키와 128비트 키(p.363 표 참고)

#### 대칭키 암호법 - 공유키 발급하기
-	대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다.
-	사용자별로 비밀 키를 생성하고 관리한다는 것은 매우 힘든 일이다.

#### 공개키 암호법 
-	한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.
-	하나는 호스트의 메시지를 인코딩하기 위한 것이며, 다른 하나는 그 호스트의 메시지를 디코딩하기 위한 것이다. 인코딩 키는 모두를 위해 공개되어 있다.
-	하지만 호스트만이 개인 디코딩 키를 알고 있다.
-	공개키 암호 방식은 대칭 키의 쌍이 N^2로 폭발적으로 증가하는 것을 피할 수 있다.
-	공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다.

#### 공개키 암호법 - RSA
-	아래의 내용이 노출되더라도 개인키를 계산할 수 없는 조건을 만족하는 공개키 암호 체계 중 유명한 하나는 MIT에서 발명되고 이어서 RSA 데이터 시큐리티에서 상용화된 RSA 알고리즘이다.
	-	공개키
	-	가로채서 얻은 암호문의 일부
	-	메시지와 그것을 암호화한 암호문

#### 공개키 암호법 - 혼성 암호 체계와 세션 키
-	비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로 훌륭하다.
-	두 노드가 안전하게 의사소통하려고 할 때 개인 키에 대한 협상을 먼저 해야 할 필요가 없다.
-	그러나 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다. 실제로는 대칭과 비대칭 방식을 썩은 것이 쓰인다.

#### 디지털 서명
-	암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는 데에 이용될 수 있다.
-	서명은 메시지를 작성한 저자가 누군지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 ‘서명’처럼 동작한다.
-	서명은 메시지 위조를 방지한다. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다. 그리고 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.

#### 디지털 인증서
-	디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

#### 디지털 인증서 - 인증성의 내부
-	디지털 인증서에는 또한 공식적으로 인증 기관에 의해 디지털 서명된 정보의 집합이 담겨있다.
	-	대상의 이름
	-	유효 기간
	-	인증서 발급자
	-	인증서 발급자의 디지털 서명
-	누구나 디지털 인증서를 만들 수 잇지만, 그 모두가 인증서의 정보를 보증하고 인증서를 개인 키로 서명할 수 있는 널리 인정받는 서명 권한을 얻을 수 있는 것은 아니다.

#### 디지털 인증서 - X.509 v3 인증서
-	디지털 인증서에 대한 전 세계적인 단일 표준은 없다. 모든 인쇄된 ID 카드가 같은 위치에 같은 정보를 담고 있지 않은 것처럼, 여러 가지 미묘하게 다른 스타일의 디지털 인증서들이 존재한다.
-	오늘날 사용되는 대부분의 인증서가 그들의 정보를 x.509라 불리는 표준화된 서식에 저장하고 있다는 것이다.

#### 디지털 인증서 - 서버 인증을 위해 인증서 사용하기
-	사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.
-	만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다. 서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.
	-	웹 사이트의 이름과 호스트명
	-	웹 사이트의 공개키
	-	서명 기관의 이름
	-	서명 기관의 서명
	-	만약 서명 기관이 모르는 곳이라면, 브라우저는 그 서명 기관을 신뢰해야 할지 확신할 수 없으므로. 대개 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여준다.

#### HTTPS의 세부사항
-	HTTPS는 HTTP의 가장 유명한 보안 버전이다.
-	널리 구현되었으며 주류 상용 브라우저와 서버에 구현되어 있다.
-	HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다. 이 기법들의 집합은 무정부 상태의 분권화된 글로벌 인터넷 환경에서도 HTTPS를 매우 안전한 동시에 매우 유연하고 관리하기 쉽게 만들어 준다.

#### HTTPS의 세부사항 - HTTPS 개요
-	HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다.
-	HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다.
-	HTTPS의 보안 계층은, SSL과 그것의 현대적 대체품인 TLS로 구현되었다.
-	우리는 SSL과 TLS 모두를 의미하는 단어로 SSL을 사용하는 관행을 따를 것이다.

#### HTTPS의 세부사항 - HTTPS 스킴
-	오늘날 보안 HTTP는 선택적이다. 따라서 웹 서버로의 요청을 만들 때, 우리는 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다.
-	이것은 URL의 스킴을 통해 이루어진다.
-	http://www.… & https://www.…
-	HTTPS는 핸드셰이크를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.
-	SSL 트래픽은 바이너리 프로토콜이기 때문에, HTTP와는 완전히 다르다.(HTTP - 80 포트, SSL - 443포트)

#### HTTPS의 세부사항 - 보안 전송 셋업
-	암호화되지 않은 HTTP에서, 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고, 요청 메시지를 보내고, 응답 메시지를 받고, 커넥션을 닫는다.
-	HTTPS에서의 절차는 SSL 보안 계층 때문에 약간 더 복잡하다. HTTPS에서, 클라이언트는 먼저 웹 서버의 443 포트로 연결한다.
-	일단 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다. 핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다.
-	이 메시지는 TCP로 보내지기 전에 암호화된다.

#### HTTPS의 세부사항 - SSL 핸드셰이크
-	핸드셰이크는 다므과 같은 일이 일어난다.
-	프로토콜 버전 번호 교환
-	양쪽이 알고 있는 암호 선택
-	양쪽의 신원을 인증
-	채널을 암호화하기 위한 임시 세션 키 생성

#### HTTPS의 세부사항 - 서버 인증서
-	보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 누군가가 웹 서버에 신용카드 정보를 보내는 것과 같은 보안 트랜잭션을 수행할 때, 그는 대화 중인 조직이 그와 대화하고 있다고 생각한 그 조직인 맞는지 알고 싶을 것이다.
-	잘 알려진 인증기관에 의해 서명된 서버 인증서는, 그가 서버에 그의 신용카드나 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다.
-	서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그리고 그 외의 정보를 보여주는, X.509 v3에서 파생된 인증서이다.

#### HTTPS의 세부사항 - 사이트 인증서 검사
-	SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 더 철절한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.
-	인증서 검사 알고리즘 수행단계
	-	날짜 검사
	-	서명자 신뢰도 검사
	-	서명 검사
	-	사이트 신원 검사

#### HTTPS의 세부사항 - 가상 호스팅과 인증서
-	가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.
-	몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다. 만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것이다.

#### 진짜 HTTPS 클라이언트
-	SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재한다.

#### 진짜 HTTPS 클라이언트 - OpenSSL
-	OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소수 구현이다.
-	C로 HTTPS 클라이언트 구현 - p.380 ~ p.386

#### 프락시를 통한 보안 트래픽 터널링
-	클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용한다.
-	이프락시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 바이러스 검사나 기타 콘텐츠 제어를 수행할 것이다.
-	그러나 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다. 그리고 만약 프락시가 HTTP 헤더를 읽을 수 없다면, 프락시 요청을 어디로 보내야 하는지도 알 수 없게 된다.
-	HTTPS가 프락시아도 잘 동작할 수 있게 하기 위해, 클라이언트가 프락시에게 어디에 접속하려고 하는지 말해주는 방법을 약간 수정해야 한다. 
-	인기 있는 기법 하나는 HTTPS SSL 터널링 프로토콜이다. HTTPS 터널링 프로토콜을 사용해서 클라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다.

#### 정리
-	HTTPS에 대해서 다시 한번 공부할 수 있는 기회가 생겼다.
-	핸드 세이크 과정에서는 인증성검사 뿐만아니라 서명검사와 다른 검사도 추가하여 한다는걸 알 수 있었다.
-	암호화 기법(대칭키&비대칭키)에 대해서 리마인드 할 수 있는 시간이였다.

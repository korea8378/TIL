# HTTP 완벽 가이드

## 5월 4일

### 15장 엔터티와 인코딩

#### 개요
-	HTTP는 매일 수십억 개의 미디어 객체를 실어나른다.
-	HTTPS는 또한 메시지가 올바르게 수송되고, 식별되고, 추출되고, 처리되는 것을 보장한다.
-	HTTP 데이터를 담은 컨테이너인 HTTP 메시지는 엔터티의 포맷과 동작방식
-	어떻게 HTTP가 엔터티 본문의 크기를 기술하며, 크기를 측정하기 위해 HTTP가 무엇을 요구하는지
-	클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공되는 엔터티 헤더들
-	공간을 적게 차지하고 더 안전하게 만들기 위해 발송자가 콘텐츠 데이터 포맷을 변형할 때 사용하는, 디코딩 가능한 콘텐츠 인코딩
-	특정 종류의 콘텐츠의 송수신을 개선하기 위해 HTTP가 데이터를 실어 나르는 방식을 수정하는 전송 인코딩. 그중에서도 길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 조각으로 쪼개 전달하는 청크 인코딩
-	클라이언트가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와주는 태그, 라벨, 시간, 체크섬의 모음
-	콘텐츠의 버전 번호처럼 동작하는 검사기들. 그리고 객체를 최신으로 유지하기 위해 설계된 HTTP 헤더 필드들
-	중단되었던 다운로드를 중단된 지점에서부터 재개하고자 할 때 유용한 범위 요청
-	클라이언트가 전에 본 적이 있었던 웹 페이지를 다시 볼 때, 그때 이후로 변경이 있는 부분만 요청할 수 있게 해주는 HTTP 델타 인코딩 확장
-	엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있지 않은지 탐지하기 위해 사용하는, 엔터티 본문 체크섬

#### 메시지는 컨테이너, 엔터티는 화물
-	HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적인 화물이다.
-	엔터티 헤더 필드
-	Content-Type
-	Content-Length
-	Content-Language
-	Content-Encoding
-	Content-Location
-	Content-Range
-	Content-MD5
-	Last-Modified
-	Expires
-	Allow
-	ETag
-	Cache-Control

#### 메시지는 컨테이너, 엔터티는 화물 - 엔터티 본문
-	엔터티 본문은 가공되지 않은 데이터만을 담고 있따.
-	Content-Encoding 엔터티 헤더는 우리에게 그 데이터가 압축되었거나 혹은 추가적인 인코딩이 되었는지 말해준다.
-	엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

#### Content-Length: 엔터티의 길이
-	Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.
-	어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다. Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.

#### Content-Length: 엔터티의 길이 - 잘림 검출
-	옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다. 그러나 Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 발생한 것인지 구분하지 못한다. 클라이언트는 메시지 잘림 검출하기 위해 Content-Length를 필요로 한다.
-	메시지 잘림은 캐싱 프락시 서버에서 특히 취약하다. 몇몇은 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 잇지 않은 HTTP 본문을 보통 캐싱하지 않는다.

#### Content-Length: 엔터티의 길이 - 잘못된 Content-Length
-	Content-Length가 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있따.
-	몇몇 클라이언트, 서버, 프락시 들은 서버가 이러한 오동작을 했는지 탐지하고 교정을 시도한다.

#### Content-Length: 엔터티의 길이 - Content-Length와 지속 커넥션
-	Content-Length는 지속 커넥션을 위해 필수다. 만약 응답이 지속 커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것이다.
-	HTTP 애플리케이션은 Content-Length 헤더 없이는 어디까지가 엔터티 본문이고 어디부터가 다음 메시지인지 알 수 없을 것이다.
-	Content-Length 헤더 없이 지속 커넥션을 만날 수 있는 상황이 하나 있다. 바로 청크 인코딩을 사용할 때다.
-	청크 인코딩은 데이터를 각각이 특정한 크기를 갖는 일련의 청크들로 쪼개어 보낸다.

#### Content-Length: 엔터티의 길이 - 콘텐츠 인코딩
-	HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔터티 본문을 인코딩할 수 있게 해준다.
-	만약 본분의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정한다.

#### Content-Length: 엔터티의 길이 - 엔터티 본문 길이 판별을 위한 규칙
-	1. 본문을 갖는 것이 허용되지 않은 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다.
-	2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 0 바이트 청크라 불리는 특별한 패턴으로 끝나야 한다.
-	3. 메시지가 Content-Length 헤더를 갖는다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
-	4. 메시지가 multipart/byteranges 미디어 타입을 사요하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다.
-	5. 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.
-	6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을 갖고 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.

#### 엔터티 요약
-	HTTP가 일반적으로 TCP/IP 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, 불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시를 비롯한 여러 가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
-	엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사를 할 수 있다.
-	Content-MD5 헤더는 서버가 엔터티 본분에 MD5 알고리즘을 적요한 결과를 보내기 위해 사용된다.
-	Content-MD5 헤더는 그다지 자주 전송되지 않는다.
-	악의적인 공격에는 면역력이 없다. 단순 의도하지 않은 변경을 찾기 위해 사용된다.

#### 미디어 타입과 차셋
-	Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.
-	MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름이다. 클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해 MIME 타입을 이용한다.
-	MIME 타입
-	주 미디어 타입으로 시작해서 뒤이어 빗금(/), 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입으로 구성된다.
-	p.402 표
-	Content-Type 헤더가 원본 엔터티 본문의 미디어 타입을 명시한다는 것은 중요하다.

#### 미디어 타입과 차셋 - 텍스트 매체를 위한 문자 인코딩
-	Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다.
-	엔터티 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 charset 매개변수가 그 대표적인 예이다.

#### 미디어 타입과 차셋 - 멀티파트 미디어 타입
-	MIME 멀티파트 이메일 메시지는 서로 붙어 있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다.
-	HTTP는 멀티파트 본문도 지원한다. 그러나 일반적으로는 폼을 채워서 제출할 때와 무선의 일부분을 실어 나르는 범위 응답을 할 때의 두 가지 경우에만 사용된다.

#### 미디어 타입과 차셋 - 멀티파트 폼 제출
-	HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다. 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.
-	p.403 ~ p.404 예시 참고

#### 미디어 타입과 차셋 - 멀티파트 범위 응답
-	범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다.
-	그러한 응답은 Content-Type:multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

#### 콘텐츠 인코딩
-	HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 한다. 예를 들어, 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 전송시간을 줄이기 위해 압축을 할 수 있다.
-	서버는 허가받지 않은 제삼자가 볼 수 없도록 콘텐츠를 암호화하거나 뒤섞어서 보낼 수도 있다.

#### 콘텐츠 인코딩 - 콘텐츠 인코딩 과정
-	1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
-	2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다르다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다.
-	3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.
-	Content-Type은 반드시 필요로한다. 원본의 타입을 알아야하기 때문이다.
-	Content-Length는 인코딩된 본문의 길이를 나타낸다.

#### 콘텐츠 인코딩 - 콘텐츠 인코딩 유형
-	HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
-	ex) gzip, compress, deflate, identity

#### 콘텐츠 인코딩 - Accept-Encoding 헤더
-	서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해 전달한다.
-	만약 HTTP 요청에 Accept-Encoding 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있는 것으로 간주한다.
-	Q 값의 범위는 가장 원치 않음을 의미하는 0.0에서 가장 선호함을 의미하는 1.0까지다.

#### 전송 인코딩과 청크 인코딩
-	콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있다. 
-	전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.

#### 전송 인코딩과 청크 인코딩 - 안전한 전송
-	전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 안전한 전송을 위해 존재했다.
-	표준화되고 더 너그러운 전송 기반을 갖춘 HTTP는 안전한 전송의 초점을 다른 데에 맞추고 있다.
-	HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 잇는 이유는 몇가지 밖에 없다.
-	1. 알 수 없는 크기 - 서버가 본문이 길이를 알기도 전에 보내고 싶을 경우
-	2. 보안 - SSL이 있기 때문에 흔히 사용되지 않는다.

#### 전송 인코딩과 청크 인코딩 - Transfer-Encoding 헤더
-	TE
-	요청 헤더
-	Trasnfer-Encoding 
-	응답 헤더
-	최신 HTTP 명세는 오직 하나의 전송 인코딩, 즉 청크 인코딩만을 정의했다.
-	HTTP/1.1 명세는 청크 인코딩에 대해 Q 값이 0.0을 갖는 것을 금지한다.
-	청크 전송 인코딩은 확장 전송 인코딩들의 최상위에서 적용되어야 할 것이다. 이것은 청크 인코딩 외에 다른 전송 인코딩을 이해하지 못하는 HTTP/1.1 애플리케이션에서도 터널링의 동작을 보장한다.

#### 전송 인코딩과 청크 인코딩 - 청크 인코딩
-	청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다.
-	서버는 각 청크를 순차적으로 보낸다. 청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.
-	본문이 동적으로 생성됨에 따라, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보낼 수 있다. 본문 전체를 모두 보낼 때까지 이 단계를 반복한다.
-	청크와 지속 커넥션(p.412 그림 참고)
-	클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다.
-	클라이언트는 서버가 커넥션을 닫을 때까지를 본문으로 간주하고 읽을 것이다.
-	청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼수 있게 해줌으로써 Content-Length의 딜레마에 대한 해법을 제공한다.
-	서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.
-	청크 인코딩 된 메시지의 트레일러
-	트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.
-	트레일로 보낼 수 있는 헤더의 예로 Content-MD5 헤더가 있다.

#### 전송 인코딩과 청크 인코딩 - 콘텐츠와 전송 인코딩의 조합
-	콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.(p.413 그림 참고)

#### 전송 인코딩과 청크 인코딩 - 전송 인코딩 규칙
-	전송 인코딩의 집합은 반드시 chunked를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.
-	청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
-	청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.
-	전송 인코딩을 구현한 서버는 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 특별히 주의해야한다.(HTTP/1.1부터 전송 인코딩이 적용 되어기때문에)

#### 시간에 따라 바뀌는 인스턴스
-	웹 객체는 정적이지 않다. 같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.
-	HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이것은 인스턴스 조작이라 불리며 객체의 인스턴스에 작요한다.
-	대표적인 두 가지가 범위 요청과 델타 인코딩이다.

#### 검사기와 신선도
-	조건부 요청이라고 불리는 특별한 요청은, 클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것이다.

#### 검사기와 신선도 - 신선도
-	서버는 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고 신선하다고 가정할 수 있는지에 대한 정보를 줄 것이다. 서버는 Expires나 Cache-Control 헤더를 통해 이러한 정보를 제공할 수 있다.
-	Expires 헤더를 바르게 사용하는 클라이언트 헤더는, 그들의 시계를 반드시 동기화시켜야 한다.
-	상대시간을 이용해 만료를 정의하는 메커니즘이 더 쓸만하다. Cache-Control 헤더는 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다.
-	수명은 시계 동기화에 의존하지 않으므로 더 정확한 결과를 말해줄 것이다.
-	Cache-Control 헤더는 실제로 굉장히 강력하다.(p.416 표 참고)

#### 검사기와 신선도 - 조건부 요청과 검사기
-	캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면 캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요가 있다.
-	p.418 표 참고
-	클라이언트가 같은 리소스에 한 번 이상 접근했을 때, 우선 현재 사본이 여전히 신선한지 판별한다.
-	만약 그렇지 않다면, 클라이언트는 반드시 서버로부터 최신 버전을 얻어 와야한다. 리소스가 변경되지 않은 상황에서 똑같은 사본을 다시 받아오는 상황을 피하기 위해, 클라이언트는 서버에 현재 사본을 유일하게 식별 할 수 잇는 검사기를 명시해서 조건부 요청을 보낼 수 있다.

#### 범위 요청
-	범위 요청을 이용하면, HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드 중단된 시점에서 재개할 수 있다.
-	객체가 처음 요청했을 때와 범위 요청을 했을 때 사이에 아무 변경이 없었다면 말이다.
-	Range 헤더는 또한 여러 범위로 요청을 하기 위해 사용될 수 있다.
-	모든 서버가 범위 요청을 받아들일 수 있는 것은 아니지만 많은 경우 가능하다.
-	서버는 클라이언트에게 자신이 범위를 받아들일 수 있는지 응답에 Accept-Range 헤더를 포함시키는 방법으로 알려줄 수 있다.

#### 델타 인코딩
-	캐시에서 갱신에서 새 페이지를 전체를 보내는 대신, 페이지에 대한 클라이언트의 사본에 대해 변경된 부분만을 서버가 보낸다면 클라이언트는 더 발리 페이지를 얻을 수 있을 것이다.
-	델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장이다.
-	A-IM 헤더를 보내서 자신이 페이지에 델타를 받아들일 수 있음을 알려줄 수도 있다.
-	클라이언트는 페이지의 예전 버전과 델타를 이용해 최신 버전의 문서를 생성하는 방법에 대한 자신이 알고 있는 알고리즘을 A-IM 헤더 안에 명시한다.
-	p.423 표참고
-	다양한 인스턴스 조작의 종류들(p.424 표참고)

#### 정리
-	캐시와 캐시 신선도 검사에 대해서 다시한번 리마인드 할 수 있었다.
-	청크 인코딩과 지속 커넥션의 연관관계를 알 수 있었다.
-	범위 요청과 델타 인코딩이라는 새로운 방식의 요청/응답에 대해서 알 수 있었다.
-	진짜 HTTP로는 다양한것들 할 수 있구나…너무 많아…

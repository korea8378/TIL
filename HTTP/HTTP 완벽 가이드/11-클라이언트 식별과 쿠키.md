# HTTP 완벽 가이드

## 4월 21일

### 11장 클라이언트 식별과 쿠키

#### 개요
- 웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다.
- 이 서버들은 익명의 클라이언트로부터 받는 모든 요청을 처리하는 것뿐만 아니라 서버와 통신하고 있는 클라이언트를 추적해야 할 수도 있다.

#### 개별 접촉
- HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.
- 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.
- 여러가지 방식으로 사이트를 개인화시켜서 사용자에게 제공한다.
    - 1. 개별인사 - 사용자에 맞게 개별 페이지 준비 등
    - 2. 사용자 맞춤 추천 - 장바구니 같은 개인 정보 등
    - 3. 저장된 사용자 정보 - 카드 번호, 비밀번호 자동입력 등
    - 4. 세션 추적 - HTTP 트랜잭션 추적
- HTTP 자체에 식별 관련 기능이 풍부하지는 않아서, 초기 웹 사이트 설계자들은 사용자를 식별하는 그들만의 기술을 개발했다.
- 각 기술은 장단점이 존재한다.
- 사용자 식별 기술
    - 1. 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
    - 2. 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
    - 3. 사용자 로그인 인증을 통한 사용자 식별
    - 4. URL에 식별자를 포함하는 기술인 뚱뚱한 URL
    - 5. 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키

#### HTTP 헤더
- From 헤더
    - 사용자의 이메일 주소를 포함한다.
    - 하지만, 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 From 헤더를 보내는 브라우저는 많지 않다.
- User-Agent 헤더
    - 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 어떤 경우에는 운영체제에 대한 정보까지 포함하여 서버에게 알려준다.
    - 이는 특정 브라우저에서 제대로 동작하도록 그것들의 속성에 맞추어 콘텐츠를 최적하는 데 유용할 수 있지만, 특정 사용자를 식별하는 데는 큰 도움이 되지 않는다.
- Refere 헤더
    - 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가르킨다.
    - 사용자가 이전에 어떤 페이지를 방문했었는지 알려준다.
- From, User-Agent, Refere 헤더들은 확실히 식별하기에는 부족한 정보를 가진다.

#### 클라이언트 IP 주소
- 초기 웹 선구자들은 사용자 식별에 클라이언트의 IP 주소를 사용하려 했다.
- 이방식은 사용자가 확실한 IP 주소를 가지고 있고, 그 주소가 좀처럼 바뀌지 않고, 웹 서버가 요청마다 클라이언트의 IP를 알 수 있다면 문제없이 동작한다.(TCP 커넥션의 IP 주소를 알 아낼 수 있다.
- 다음과 같은 약점
    - 1. 사용하는 컴퓨터를 가리킨다.(다수의 인원이 하나의 컴퓨터를 사용한다면?)
    - 2. 인터넷 서비스 제공자를 사용하면 IP가 계속해서 바뀐다.
    - 3. 네트워크 주소 변환 시스템을 사용하는 경우 실제 유저의 IP를 알수 없다.(시스템 뒤에 존재하기 때문에)
    - 4. 프락시와 게이트웨이를 사용하게 된다면?
- 인트라넷 같이 제한된 영역에서는 적절할 수 있지만, 인터넷에서는 IP 주소를 임의로 변경할 수 있기 때문에 문제가 발생할 수 있다.

#### 사용자 로그인
- 웹 서버는 사용자 이름과 비밀번호로 인증 할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
- HTTP는 WWW-Authenticate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
- 한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.
- p.302 그림 참고

#### 뚱뚱한 URL
- 어떤 웹 사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적하였다.
- 보통, URL은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다.
- 뚱뚱한 URL은 사이트를 브라우징하는 사용자를 식별하는 데 사용할 수 있다. 하지만 이 기술에는 여러가지 심각한 문제가 있다.
    - 1. 못생긴 URL - 사용자에게 혼란
    - 2. 공유하지 못하는 URL - 특정 사용자의 정보를 가지고 있기 때문에 공유 불가
    - 3. 캐시를 사용할 수 없음 - URL이 계속 달라지기 때문에 캐시 불가
    - 4. 서버 부하 가중 - 뚱뚱한 URL에 해당하는 html 페이지를 다시 생성
    - 5. 이탈 - 뚱뚱한 URL을 잃어 버리면 다시 처음 부터 동작
    - 6. 세션 간 지속성의 부족  - 로그아웃하는 순간 뚱뚱한 URL을 잃어 버린다.

#### 쿠키
- 쿠키는 사용자르 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.
- 쿠키만으로는 하기 힘든 일에는 위의 설명한 기술들을 함께 사용하기도 한다.
- 쿠키는 매우 중요한 웹 기술일 뿐만 아니라 새로운 HTTP 헤더를 정의한다.
- 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

#### 쿠키 - 쿠키의 타입
- 세션 쿠기
    - 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키다.
    - 사용자가 브라우저를 닫으면 삭제된다.
- 지속 쿠키
    - 브라우저를 닫아도 삭제되지 않고 더 길게 유지될 수 있다.
    - 디스크에 저장되어, 브라우저 닫거나 컴퓨터를 재시작하더라도 남아있다.
- 세션 쿠키와 지속 쿠키의 다른 점은 파기되는 시점뿐이다.

#### 쿠키 - 쿠키는 어떻게 동작하는가
- 처음에 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해서 아무것도 모른다.
- 웹 서버는 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.
- 쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 혹은 Set-Cookie2 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달된다.
- 쿠키는 어떤 정보든 포함할 수 있지만, 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다.
- 쿠키는 단순히 ID 번호에만 국한되지 않는다. 많은 웹서버가 정보를 쿠키에 유지하려고 한다.

#### 쿠키 - 쿠키상자:클라이너트 측 상태
- 쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것이다.
- 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 ‘클라이언트 측 상태’라고 한다.(공시적인 이름은 HTTP 상태 관리 체계)
- 각 브라우저는 각기 다른 방식으로 쿠키를 저장한다.
    - 구글 크롬 쿠키
        - SQLite 파일에 쿠키를 저장
    - 마이크로소프트 인터넷 익스플로러 쿠키
        - 캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장한다.

#### 쿠키 - 사이트마다 각기 다른 쿠키들
- 브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만, 그렇다고 브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다.
- 브라우저는 보통 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다. 이유는 아래와 같다.
    - 1. 성능 저하 
    - 2. 서버에 특화된 이름/값으로 구성
    - 3. 특정 사이트에서 제공하지 않는 쿠키까지 받을 필요가 없음
- 많은 웹 사이트는 광고를 관리하는 협력업체와 계약을 한다. 이 광고들은 웹사이트 자체의 일부인 것처럼 제작되고, 지속 쿠키를 만든다.(광고사가 사용자의 습관 및 유입 접근 경로를 파악할 수 있게 해준다.)
- 쿠키 Domain 속성
    - 서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.
- 쿠키 Path 속성
    - 웹 사이트 일부에만 쿠키를 적용할 수 있다.
- 쿠키는 일종의 상태 정보라고 할 수 있으며, 서버가 생성하여 클라이언트에 전달하고, 클라이언트는 그 쿠키를 유효한 사이트에만 다시 전달하고 관리한다.

#### 쿠키 - 쿠키 구성요소
- 현재 사용되는 쿠키 명세에는 Version 0 쿠키(넷스케이프 쿠키)와 Version 1 쿠키가 있다.
- Version 쿠키는 Version 0 쿠키의 확장으로 널리 쓰이지 않는다.

#### 쿠키 - Version 0 쿠키
- 최초의 쿠키 명세는 넷스케이프가 정의했다. 이 Version 0 쿠키는 Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필요한 필드들을 정의하였다.
- Version 0 Set-Cookie 헤더
    - Set-Cookie 헤더는 쿠키의 이름과 값을 가져야 한다.
    - p.311 참고
- Version 0 Cookie 헤더
    - 클라이언트가 서버에 요청을 보낼 때는, Domain, Path, Secure 필터들이 현재 요청하려고 하는 사이트에 들어맞으면서 아직 파기되지 않은 쿠키들을 함께 보낸다.

#### 쿠키 - Version 1 쿠키
- 쿠키의 확장된 버전은 RFC 2965에 정의되어 있다. Version 1 표준은 Set-Cookie2와 Cookie2 헤더를 소개하고 있으며 Version 0 시스템과도 호환된다.
- 변경사항은 다음과 같다.
    - 쿠키마다 그 목적을 설명하는 설명문이 있다.
    - 파기 주기에 상관없이 브라우저가 닫히면 쿠키를 강제로 삭제할 수 있다.
    - 절대 날짜 값 대신에 초 단위의 상대 값으로 쿠키의 생명주기를 결정할 수 있는 Max-Age.
    - 단순히 도메인과 경로뿐 아니라 URL의 포트번호로도 쿠키를 제어할 수 있다.
    - 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보낸다.
    - 호환되는 버전 번호
    - 사용자 이름과 추가적인 키워드를 구별하기 위해 Cookie 헤더에 $접두어가 있다.
- Version 1 Set-Cookie2 헤더
    - Version 1 쿠키 표준에는 넷스케이프 표준보다 더 많은 속성이 있다.
    - p.314 참고
- Version 1 Cookie 헤더
    - Version 1 Cookie는 전송하려는 각 쿠키에 추가 정보를 담는데, 추가 정보에는 해당 쿠키가 가지고 있던 필터 중에서 현재의 사이트에 들어맞는 필터를 기술한다.
    - 해당 쿠키의 Set-Cookie2 필터 중에서, 현재의 웹 사이트에 들어맞는 필터 정보에 달러 문자($)을 붙여서 쿠키와 함께 전송한다.
- Version 1 Cookie2 헤더와 버전 협상
    - Cookie2 요청 헤더는 각기 다른 쿠키 버전을 지원하는 클라이언트와 서버 간에 호환성을 협상하는 용도로 사용한다.

#### 쿠키 - 쿠키와 세션 추적
- 쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다.(세션 쿠키 사용)
- p.316 ~ p.317 아마존 쇼핑몰 절차 참고

#### 쿠키 - 쿠키와 캐싱
- 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다. 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보를가 다른 이에게 노출되는 최악의 상황이 일어날 수도 있다.
- 쿠키와 캐싱에 관련된 규칙은 정리가 잘 되어 있지 않다. 그렇기 때문에 아래와 같이 기본 원칙을 지키자.
    - 1. 캐시되지 말아야 할 문서가 있다면 표시하라.
        - 문서를 캐시하면 될지 안 될지는 문서의 소유자가 가장 잘 안다.(서버가 Control 헤더와 Cache-Control 헤더를 이용해서 제어할 수 있다.)
    - 2. Set-Cookie 헤더를 캐시 하는 것에 유의하라.
        - 만약 응답이 Set-Cookie 헤더를 가지고 있으면, 본문은 캐시할 수 있지만, Set-Cookie 헤더를 캐시하는 것은 주의를 기울여야 한다.(사용자 추적을 실패할 수 있다.)
    - 3. Cookie 헤더를 가지고 있는 요청을 주의하라.
        - 요청이 Cookie 헤더와 함께 오면, 결과 콘텐츠가 개인정보를 담고 있을 수도 있다는 힌트다.(개인정보는 캐시 금지, 하지만 그 표시를 하지 않는 서버도 있다.)

#### 쿠키 - 쿠키, 보안 그리고 개인정보
- 쿠키를 사용하지 않도록 비활성화시킬 수 있고, 로그 분석 같은 다른 방법으로 대체하는 것도 가능하므로, 그 자체가 보안상으로 엄청나게 위험한 것은 아니다.
- 사실, 원격 데이터베이스에 개인 정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 사용하면, 클라이언트와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있다.
- 쿠키에 대한 부정적인 여론이 많기 하지만, 제공하는 개인정보를 누가 받는지 명확히 알고 사이트의 개인정보 정책에만 유의한다면, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.

#### 정리
- 쿠키 말고도 다양한 방식으로 세션을 유지할 수 있다는 것을 알게 되었고 그 방법들보다는 쿠키가 좀 더 효율적이면 같이 사용하여 시너지를 낼 수 있다는걸 알게 되었다.
- Cookie Version 1은 현재 폐지가 되었다고 한다. 복잡해서 그러는 걸까??? 아니면 Version 0으로도 다 커버가 가능하기 때문일까??
- 마지막 부분에서 협력업체 웹 사이트가 사용자를 추적하려고 지속 쿠키를 사용하는 것은 오용이라고 말하고 있는데 이부분이 잘 이해가 되지 않는다. 찾아 봐야겠다.

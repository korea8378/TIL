# HTTP 완벽 가이드

## 4월 9일

### 10장 HTTP

#### 개요
- HTTP/2.0에 대해서, 만들어지기 시작하게 된 배경, HTTP/1.1과의 주요 차이점, 현재까지 알려진 보안 이슈에 대해 알아보자

#### HTTP/2.0의 등장 배경
- HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.
- 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받은 HTTP의 메시지 교환 방식은 단순함 면에서는 더할 나위 없었지만, 응답을 받아야만 그다음 요청을 보낼 수 있기 때문에 심각한 회전 지연을 피할 수 없었다.
- 이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 성능 개선에 대한 근본적인 해결책은 되지 못했다.
- 구글에서 웹을 더빠르게 하겠다는 목표 아래 SPDY 프로토콜을 내놓았다.
- SPDY는 기존의 HTTP에 속도를 개선하기 위한 여러 기능을 추가한 것이다.
- SPDY
    - 대역폭을 절약
    - 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능
    - 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능
- HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0프로토콜을 설계하였다.

#### HTTP2.0 
- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이때 TCP 커넥션을 초기화하는 것은 클라이언트다.
- HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담긴다. 이때 헤더는 압축되어 담긴다.
- 프레임 & 스트림
    - 프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다. 한 개의 스트림이 한쌍의 요청과 응답을 처리한다.
    - 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것 역시 가능하다.
    - 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공한다.
- 서버 푸시 
    - 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 그에 대한 요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에게 보내줄 수 있다.
    - 기존 웹 애플리케이션들과 호환성을 최대한 유지하기 위해, HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고 있다.
- 표현하는 문법 변경
    - ex) Content-Length -> :content-length, 404 Not Found -> :status(헤더) 404

#### HTTP/1.1과의 차이점 - 프레임
- HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다.
- 헤더 - 8바이트
- 페이로드 - 최대 16383바이트

#### HTTP/1.1과의 차이점 - 스트림과 멀티플렉싱
- 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다.
    - 1. 클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보낸다.
    - 2. 요청을 받은 서버는 그 요청과 같은 스트림으로 응답을 보낸다.
    - 3. 그러고 나면 스트림이 닫히게 된다.
- HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보냈을 때, 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있다.
- 웹브라우저들은 회전 지연을 줄이기 위해 여러 개의 TCP 커넥션을 만들어 동시에 여러 개의 요청을 보내는 방법을 사용한다.(병렬 커넥션, 파이프라인 커넥션 등)
- HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.
- 따라서 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청이 동시에 보내질 수 있기 때문에 이 문제는 쉽게 해결될 수 있었다.
- 또한 요청하는 스트림에게 더 높은 우선순위를 부여할 수 있다.
- 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수여야 하며 서버라면 짝수여야한다.(31비트의 무부호 정수로 된 고유한 식별자)
- 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만든다. 이는 스트림을 만들 때 협상을 위해 TCP 패킷을 주고받느라 시간을 낭비하지 않아도 됨을 의미한다.
- HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다. 커넥션을 오래 사용하다보면 스트림에 할당할 수 있는 식별자가 고갈되기도 하는데, 그런 경우엔 커넥션을 다시 맺으면 된다.
- HTTP/2.0은 WINDOW_UPDATE 프레임을 이용한 흐름 제어를 통해, 스트림들이 서로 간섭해서 망가지는 것을 막아준다.

#### HTTP/1.1과의 차이점 - 헤더 압축
- HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송되었다.
- 웹페이지를 하나를 보기 위해 수십에서 많으면 수백 번의 요청을 보내기 때문에, 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었다.
- HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송하여 문제를 개선하였다.
- 압축 콘텍스트를 사용
    - 이 합축 콘텐스트는 수신한 헤더의 압축을 풀면 이에 영향을 받아 바뀐다.
    - 사용하지 않더라도 반드시 압축 해제를 수행해야 한다.

#### HTTP/1.1과의 차이점 - 서버 푸시
- HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
- 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.
- 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야 한다.
- 클라이언트가 PUSH_PROMISE 프레임을 받게 되면 해당 프레임의 스트림은 클라이언트 입장에서는 예약됨 상태가 된다.
- 이 상태에서 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절할 수 있다.
- RST_STREAM을 보내게 되면 그 스트림은 즉각 닫히게 된다. 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안된다.
- 사전에 PUSH_PROMISE 프레임을 먼저 보내는 이유는 서버가 푸시하려고 하는 자원을 클라이언트가 별도 또 요청하게 되는 상황을 피하기 위함이다.
- 주의점
    - 서버를 푸시를 사용하기로 했더라도, 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있다. 반대로 아무런 추가 리소르를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소르르 전달할 수도 있다.
    - 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다.
    - 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.
    - 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 한다.(SOP)
    - 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH을 0으로 설정하면 된다.

#### 알려진 보안 이슈
- 중개자 캡슐화 공격
    - HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환 할 때 메시지의 의미가 변질될 가능성이 있다.
    - HTTP/1.1과는 달리 HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩 한다.
    - 이는 HTTP/2.0이 헤더 필드로 어떤 문자열이든 사용할 수 있게 해준다.
    - 이는 정상적인 HTTP/2.0 요청이나 응답이, 불법적이거나 위조된 HTTP/1.1 메시지로 변역되는 것을 유발할 수 있다.
    - 다행히 역으로는 이런 문제가 발생하지 않는다.(HTTP/1.1 -> HTTP/2.0)
- 긴 커넥션 유지로 인한 개인정보 누출 우려
    - HTTP/2.0은 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다.
    - 이것은 개인 정보의 유출에 악용될 가능성이 있다. 
    - 어떤 사용자가 브라우저를 사용할 때, 그 사용자는 이전에 그 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성도 있다.
    - 이것은 HTTP가 현재 갖고 있는 문제이기도 하지만, 짧게 유지는 되는 커넥션에서는 위험이 적다.

#### 정리
- HTTP/2.0과 HTTP/1.1의 차이점을 알게 되었고 어떤점을 중점으로 개선하였는지 명확하게 알 수 있었다.
- HTTP/2.0은 응답과 요청을 스트림과 프레임을 이용하여 커넥션의 지연부분 문제가 매우 개선되었다고 생각 된다.
- 하지만 현재 프록시를 많이 사용되고 있는데 프록시와 Upstream과의 2.0은 의미가 있을까?
- HTTP/2.0을 사용하기 위해서는 HTTPS를 반드시 같이 사용해야하지 않을까??

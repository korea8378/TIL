# HTTP 완벽 가이드

## 10월 25일

### 7장 캐시

#### 캐시
- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다.
- 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.
- 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 올 수 있게 된다.
- 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.
- 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

#### 불필요한 데이터 전송
- 복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송하게 된다.
- 캐시를 이용하면, 서버 응답은 캐시에 보관된다.
- 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용 될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 된다.

#### 대역폭 병목
- 캐시는 네트워크 병목을 줄여준다.
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
- 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같다.

#### 갑자스런 요청 쇄도
- 캐싱은 갑자스런 요청 쇄도에 대처하기 위해 특히 중요하다.
- 갑자스런 사건(뉴스 속보, 스팸 메일, 유명 인사와 관련된 사건등)으로 많은 사람이 거의 동시에 웹 문서에 접근할 때 이런 일이 발생한다.
- 이 결과로 초래된 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기 시킨다.

#### 거리로 인한 지연
- 비록 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있다.
- 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.
- 그리고 클라이언트와 서버 사이에 라우터가 그다지 많지 않더라도, 빛의 속도 그 자체가 유의미한 지연을 유발한다.
- 기계실 근터에 캐시를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.

#### 적중과 부적중
- 캐시는 유용하다.
- 그러나 캐시가 세상 모든 문서의 사본을 저장하지는 않는다.
- 캐시 적중
    - 캐시에 요청이 도착했을 때, 만약 그에 대응하나는 사본이 있다면 그를 이용해 요청이 처리될 수 있다.
- 캐시 부적중
    - 대응하는 사본이 없다면 그냥 원 서버로 전달되기 만 한다.

#### 재검사
- 신선도 검사
    - 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.
- 효과적인 재검사를 위해, HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선하지 빠르게 검사할 수 있는 특별한 요청을 정의 했다.
- 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다.
- 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다.
- 재검사 적중 혹은 느린 적중
    - 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modifed 응답을 보낸다.
- 재검사 적중은 혹은 느린 적중은 캐시 적중보다 느린데, 원 서버와 검사를 할 필요가 있기 때문이다.
- 그러나 캐시 부적중보다는 빠른데, 서버로부터 객체 데이터를 받아올 필요가 없기 때문이다.
- HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그중에서 가장 많이 쓰이는 것은 If-Modifed-Since 헤더이다. 
- 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.
- GET If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 세가지 상황
    - 재검사 적중
    - 재검사 부적중
    - 객체 삭제

#### 적중률
- 캐시가 요청을 처리하는 비율 캐시 적중률, 혹은 문서 적중률이라고 부르기도 한다.
- 적중률은 0에서 1까지의 값으로 되어 있지만, 흔히 퍼센트로 표현되기도 한다.
- 0%는 모든 요청이 캐시 부적중임을, 그리고 100%는 모든 요청이 캐시 적중임을 의미한다.
- 적중률은 예측하기 어려운것으로 악명이 높지만 오늘날 적중률 40%면 웹 캐시로 괜찮은 편이다.
- 보통 크기의 캐시라도 충분한 분량의 자주 쓰이는 문서들을 보관하여 상당히 트래픽을 줄이고 성능을 개선할 수 있다.

#### 바이트 적중률
- 문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않는다.
- 몇몇 큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는 더 크게 기여한다.
- 이런 이유로, 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호한다.
- 문서 적중률을 개선하면 전체 대기시간이 줄어든다.
- 바이트 단위 적중률의 개선은 대역폭을 절약을 최적화한다.

#### 적중과 부적중의 구별
- 불행히도, HTTP는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근이인지 말해줄 수 있는 방법을 제공하지 않는다.
- 두 경우 모두 응답 코드는 응답이 본문을 갖고 있음을 의미하는 200 OK가 될 것이다.
- 어떤 상용 프락시 캐시는 캐시에 무슨 일이 일어났는지 설명하기 위해 Via 헤더에 추가 정보를 붙인다.
- 클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 Date 헤더를 이용하는 것이다.
- 응답의 Date 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다.

#### 캐시 토폴로지
- 캐시는 한 명의 사용자에게만 할달됭 수도 있고 반대로 수천 명의 사용자들 간에 공유될 수도 있다.
- 한명에게만 할당된 캐시를 개인 전용 캐시라 부른다.
- 개인 전용 캐시
    - 개인만을 위한 캐시이므로, 한 명의 사용자가 자주 찾는 페이지를 담는다.
- 공유된 캐시
    - 공용 캐시라고 불린다. 공용캐시는 사용자 집단에게 자주 쓰이는 페이지를 담는다.

#### 개인 전용 캐시
- 개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있다.
- 웹브라우저는 개인 전용 캐시를 내장하고 있다. 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

#### 공용 프락시 캐시
- 공용 캐시는 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다.
- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입자에서 서버에 접근한다.
- 공용 캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.
- 캐시는 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄인다.

#### 프락시 캐시 계층들
- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 ‘걸러 남겨진’ 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.
- 프락시 연쇄가 길어질수록 각 중간 프락시는 현저한 성능 저하가 발생할 것이다.

#### 캐시망, 콘텐츠 라우팅, 피어링
- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다.
- 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지 대한 캐시 커뮤니케이션 결정을 동적으로 내린다.
- 캐시망 안에서 콘텐츠 라우팅을 위해 설계뙨 캐시들이 하는 일
    - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
    - URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
    - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
    - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않는다.

#### 캐시 처리 단계
- 오늘날 상용 프락시 캐시는 꽤 복잡하다. 매우 고성능이면서도 HTTP와 그 외 다른 기술의 고급 기능을 지원하도록 만들어졌다.
- 처리 단계
    - 1.요청 받기
        - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
    - 2.파싱
        - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
    - 3.검색
        - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다.
    - 4.신선도 검사
        - 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.
    - 5.응답 생성
        - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
    - 6.발송
        - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
    - 7.로깅
        - 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.

#### 사본을 신선하게 유지하기
- 캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아니다.
- 결국 문서들은 시간에 따라 변경된다. 보고서는 매달 바뀔 수 있다. 온라인 신문은 매일 바뀐다. 금융 자료는 매 초 변경될 수 있다.
- 오래된 데이터를 제공하는 캐시는 불필요하다. 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 한다.

#### 문서 완료
- HTTP는 Cache-Controlr과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
- 캐시 문서가 만료되기 전에, 캐시는 필요하다면 서버와의 접촉 없이 사본을 제공할 수 잇다.

#### 유효기간과 나이
- 서버는 응답 본문 함께하는, HTTP/1.0+ Expires나 HTTP/1.1 Cache-Control:max-age 응답 헤더를 이용해서 유효기간을 명시한다.
<pre><code>
Expires : Fri, 05 Jul 2002, 05:00:00 GMT

Cache-Control: max-age=484200
</code></pre>

#### 서버 재검사
- 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않으며, 다만 이제 검사할 시간이 되었음을 뜻한다.
- 이 검사를 캐시가 원 서버에게 문서가 변경되었는지 여부를 물어볼 필요가 있음을 의미하는 ‘서버 재검사’라고 부른다.
- 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게 보내준다.
- 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.
- HTTP 프로토콜은 캐시가 아래 중. 하나를 반환하는 적절한 행동을 할 것
    - ‘충분히 신선한’ 캐시된 사본
    - 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확실할 수 있는 캐시된 사본
    - 에러 메시지
    - 경고 메시지가 부탁된 캐시된 사본

#### 조건부 메서드와 재검사
- HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.
- HTTP는 캐시가 서버에게 ‘조건부 GET’이라는 요청을 보낼 수 있도록 해준다. 
- 이요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.
- 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다.
- HTTP는 다섯 가지 조건부 요청 헤더를 정의한다. 그 중 둘은 캐시 재검사를 할 때 가장 유용한 If-Modified-Since와 If-None-Match이다.

#### If-Modified-Since : 날짜 재검사
- 가장 흔히 쓰이는 캐시 재검사 헤더는 If-Modified-Since이다.
- If-Modified-Since 재검사 요청은 흔히 ‘IMS’ 요청으로 불린다. IMS 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.
- 만약 문서가 주어진 날짜 이후에 변경되었다면, If-Modified-Since 조건은 참이고, 따라서 GET 요청은 평범하게 성공한다. 
- 새 문서가, 새로운 만료 날짜와 그외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환된다.
- 만약 문서가 주어진 날짜 이후에 변경되지 않았다면 조건은 거짓이고, 서버는 작은 304 Not Modified 응답 메시지를 클라이언트에게 돌려준다. 효율을 위해 본문은 보내지 않는다.
- 응답은 헤더들을 포함하지만, 원래 돌려줘야 할 것에서 갱신이 필요한 것만 보내준다. 예를 들어, Content-Type 헤더는 잘변하지 않기 때문에 대개 보내줄 필요가 없고, 새 만료 날짜는 보통 보내주게 된다.
- If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작한다.
- 몇몇 웹 서버는 If-Modified-Since를 실제 날짜 비교로 구현하지 않는다.
- 대신 그들은 IMS 날짜와 최근 변경일 간의 문자열 비교를 수행한다.

#### If-None-Match : 엔터티 태그 검사
- 다음과 같이 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황이 몇 가지 있다.
    - 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만 실제로는 같은 데이터를 포함하고 있다. 내용에는 아무런 변화가 없더라도 변경시각은 바뀔 수 있다.
    - 어떤 문서들의 변경의 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수도 있다.
    - 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별 할 수 없다.
    - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다.
- 퍼블리셔가 문서를 변경했을 때, 그 문서의 엔터치 태그를 새로운 버전을 표현할 수 있다.
- 엔터티 태그가 변경되었다면, 캐시는 새 문서의 사본을 얻기 위해 If-None-Match 조건부 헤더를 사용할 수 있다.
- 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, 그 사실을 서버에게 알리기 위해 하나의 If-None-Match 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있다.

#### 약한 검사기와 강한 검사기
- 캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔터티태그를 사용한다.
- 이 경우, 엔터티 태그와 최근 변경일시는 둘 다 캐시 검사기다.
- 서버는 때때로 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있다.
- 약한 검사기
    - HTTP/1.1은, 비록 콘텐츠가 조금 변경되었더라도 “그 정도면 같은 것”이라고 서버가 주장할 수 있도록 해준다.
- 강한 검사기
    - 콘텐츠가 바뀔 때마다 바뀐다.
- 강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 한다.
- 약한 엔터티 태그는 대응하는 엔터티에 유의미한 변경이 있을 때마다 같이 변경되어야 한다.
- 원 서버는 서로 다른 두엔터티에 대해 강한 엔터티 태그값을 재활용해서는 안되며, 약한 엔터티 태그 값이라고 할지라도 서로 의미가 다른 두 엔터티에 대해서는 재활용해서는 안된다는 것에 주의하자.

#### 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가
- HTTP/1.1 클라이언트는 만약 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야 한다.
- 만약 서버가 Last-Modified 값만 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.
- 만약 엔터티 태그와 최근 변경일시가 모두 사용가능하다면, HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 클라이언트는 각각을 위해 두 가지의 재검사 정책을 모두 사용해야 한다.
- HTTP/1.1 원서버는 실현 불간아하지만 않다면 엔터티 태그 검사기를 보내야 하며, 이점이 있다면 강한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수도 있다. 또한 Last-Modified 값을 같이 보내는 것도 선혼된다.
- 만약 HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면, 요청의 모든 조건부 헤더 필드의 존거에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안된다.

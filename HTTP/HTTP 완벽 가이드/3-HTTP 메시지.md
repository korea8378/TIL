# HTTP 완벽 가이드

## 09월 26일

### 3장 HTTP 메시지

#### 메시지의 흐름
- HTTP 메시지는 HTTP 어플리케이션 간에 주고받은 데이터의 블록들이다.
- 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.
- 이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.
- 메시지의 방향
    - 인바운드, 아웃바운드, 업스트림, 다운스트림

#### 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 메시지가 원 서버로 향하는 것은 인바운드
- 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드

#### 다운스트림으로 흐르는 메시지
- 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다.
- 메시지의 발솔자는 수신자의 업스트림이다.

#### 메시지의 각 부분
- HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
- 메시지는 시작줄, 헤더 블록, 본문 이렇게 세부분으로 이루어진다.
- 시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 아예 없을 수도 있다.
- 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다.
- 엔티티 본문이나 메시지 본문은 단순히 선택적인 데이터 덩어리이다. 시작줄이나 헤더와는 달리, 본문은 테스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있다.
- Content-Type 줄은 본문이 무엇인지 말해준다. Content-Length 줄은 본문의 크기를 말해준다.

#### 메시지 문법
- 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다. 요청과 응답 모두 기본적으로 구조가 같다
<pre><code>
//요청 메시지
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>

//응답 메시지
<버전><상태코드><사유 구절>
<헤더>

<엔터티 본문>
</code></pre>

#### 메시지 문법 - 메서드
- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다.
    - ex) GET, HEAD, POST…

#### 메시지 문법 - 요청 URL
- 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹인 URL의 경로 구성요소다. 완전한 URL이 아닌 URL의 경로 구성요소라고 해도, 클라이언트가 서버와 직접 대화하고 있고 경로 구셩요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다.
- 서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 것이다.

#### 메시지 문법 - 버전
- 메시지에서 사용 중인 HTTP 버전이다.
<pre><code>
HTTP/<메이저>,<마이너>
</code></pre>
- 메이저 마이너는 모두 정수이다.

#### 메시지 문법 - 상태 코드
- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자다. 각 코드의 첫 번째 자릿수는 상태의 일반적인 분류를 나타낸다.

#### 메시지 문법 - 사유 구절
- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다.
- 사유 구절은 오로지 사람에 읽히기 위한 목적으로만 존재하는 것이다.

#### 메시지 문법 - 헤더들
- 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들, 이 헤더의 목록은 빈 줄로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.
- 몇몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함되어야만 유효한 것으로 간주한다.

#### 메시지 문법 - 엔터티 본문
- 엔터티 본문은 임의의 데이터 블록을 포함한다. 모든 메시지가 엔터티 본문을 갖는 것은 아니다.
- 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈줄로 끝나야 함에 주의하자
- 널리 쓰이지만 규칙을 잘 지키지 않는 구현체와의 호환을 위해, 클라이언트와 서버는 마지막 CRLF 없이 끝나는 메시지도 받아들일수 있어야 한다.

#### 시작줄
- 모든 HTTP 메시지는 시작줄로 시작한다.
- 요청 메시지의 시작줄은 무엇을 해야하는지 말해준다.
- 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

#### 시작줄 - 요청줄
- 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. 
- 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나냐 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.
- 또한 요청줄은 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함한다.

#### 시작줄 - 응답줄
- 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
- 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어 있다.

#### 시작줄 - 메서드
- 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.
- HTTP 명세는 공통 요청 메서드의 집합을 정의한다.
    - ex) GET 메서드는 서버에서 문서를 가져오는 것, POST 메서드는 서버가 처리해줬으면 하는 데이터를 보내는 것, OPTIONS 메서드는 웹서버의 일반적인 지원 범위 혹은 웹 서버의 특정 리소스에 대한 지원 범위를 알아보는 것
- 확장 메서드
    - HTTP는 쉽게 확장 할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수도 있다.

#### 시작줄 - 상태 코드
- 메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해준다.
- 상태 코드들은 세 자리 숫자로 된 그들의 코드값을 기준으로 묶인다. 200에서 299까지의 상태 코드는 성공을 나타낸다. 300에서 399까지의 코드는 리소스가 옮겨졌음을 뜻한다. 400에서 499까지의 코드는 클라이언트가 뭔가 잘못된 요청을 했음을 의미한다. 500에서 599까지의 코드는 서버에서 뭔가 실패했음을 의미한다.
- 인식할 수 없는 상태 코드를 받게 되면, 누군가가 현재 프로토콜의 확장으로 그것을 정의햇을 가능이 있다. 그 상태 코드를 그것이 포함되는 범주의 일반적인 구성원으로 가정하고 다루어야 한다.

#### 시작줄 - 사유 구절
- 상태 코드에 대한 글로 된 설명을 제공한다.
- 사유 구절은 상태 코드와 일대일로 대응된다. 사유 구절은, 애플리케이션 개발자들이 그들의 사용자에게 요청 중에 무슨 일이 일어났는지 알려주기 위해 넘겨줄 수 있는, 상태 코드의 사람이 이해하기 쉬운 버전이다.

#### 시작줄 - 버전 번호
- 버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술 된다.
- 이것은 HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.
- HTTP/1.0 애플리케이션이 버전 번호가 HTTP/1.1로 된 응답을 받았을 때, 이를 HTTP/1.1 메시지라고 해석하는 경우가 있기 때문이다.
- 응답의 프로토콜 버전이 HTTP/1.1이라는 것은 사실 응답을 보낸 애플리케이션이 HTTP/1.1까지 이해할 수 있음을 의미하는 것이다.

#### 헤더
- 시작줄 다음에는 0개, 1개 혹은 여러 개의 HTTP 헤더가 온다.
- HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 그들은 기본적으로 이름/값 쌍의 목록이다.

#### 헤더 - 헤더 분류
- HTTP 명세는 헤더 필드를 정의한다.
- 일반 헤더
    - 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더
    - 요청에 대한 부가 정보를 제공
- 응답 헤더
    - 응답에 대한 부가 정보를 제공
- Entity 헤더
    - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더
    - 명세에 정의되지 않은 새로운 헤더

#### 헤더를 여러줄로 나누기
- 긴 헤더 줄은 그들을 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야한다.
<pre><code>
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
	Version 1.0
</code></pre>

#### 엔티티 본문
- HTTP 메시지의 세 번째 부분은 선택적인 엔터티 본문이다.
- 엔터티 본문은 HTTP 메시지의 화물이라고 할 수 있다.
- HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자 우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.

#### 버전 0.9 메시지
- HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전이다. 단순한 프로토콜로 되어 있다.
- HTTP/0.9 메시지도 마찬가지로 요청과 응답으로 이루어져 있지만, 요청은 그저 메서드와 요청 URL를 갖고 있을 뿐이며, 응답은 오직 엔터티로만 되어 있다.
- 버전 정보도 없고, 상태 코드나 사유 구절도 없으며, 헤더도 포함되어 있지 않다. 
- 단순하다. 다양한 상황에 대처할 수 없다.

#### 메서드
- 모든 서버가 모든 메서드를 구현하지 않는다는 것에 주의하자.
- HTTP 버전 1.1과 호환 되고자 한다면, 서버는 자신의 리소스에 대해 GET과 HEAD 메서드만 구현하는 것으로 충분하다.
- 비록 서버가 모든 메서드를 구현하지 않았다 하더라도 메서드는 대부분 제한적으로 사용될 것이다.

#### 메서드 - 안전한 메서드
- HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다.
- GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 어떤 작용도 없음을 의미한다.
- 작용이 없다
    - HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 의미이다.
- 안전한 메서드가 서버에 작용을 유발하지 않는다 보장은 없다.
- 안전한 메서드의 목적
    - 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.

#### 메서드 - GET
- GET은 가장 흔히 쓰이는 메서드다.
- 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

#### 메서드 - HEAD
- HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만 돌려준다.
- 엔티티 본문은 결코 반환되지 않는다. 이는 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.
- HEAD 사용 이유
    - 리소를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
    - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
    - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
- 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.

#### 메서드 - PUT
- PUT 메서드는 서버에 문서를 쓴다.
- PUT 메서드의 의미
    - 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

#### 메서드 - POST
- POST 메서드는 서버에 입력 데이터를 전송하기 위해서 설계되었다.
- 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳에 보낸다.

#### 메서드 - TRACE
- 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다.
- 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다. 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
- TRACE 요청은 목적지 서버에서 ‘루프백’ 진단을 시작한다.
- 클라이언는 자신의 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.
- TRACE 메서드는 주로 진단을 위해 사용된다.
    - ex) 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있다. 또한 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다.
- 많은 HTTP 애플리케이션은 메서드에 따라 다르게 동작한다.
- TRACE는 메서드를 구별하는 매커니즘을 제공하지 않는다. 어떻게 TRACE 요청을 처리할 것인지에 대해서는 일반적으로 중간 애플리케이션에서 결정을 내린다.
- TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없다. TRACE 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.

#### 메서드 - OPTIONS
- OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
- 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어 볼 수 있다.
- OPTIONS 메서드는 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공한다.

#### 메서드 - DELETE
- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
- But 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. 왜냐하면 HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

#### 메서드 -  확장 메서드
- HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.
- 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드다.
- 모든 확장 메서드가 형식을 갖춘 명세로 정의된 것은 아니라는 점에 주의해야 한다.
- 확장 메서드를 다룰 때는 “엄격하게 보내고 관대하게 받아들여라”라는 규칙에 따르는 것이 가장 좋다.

#### 상태 코드 
- HTTP 상태 코드는 크게 다섯 가지로 나뉜다.
- 상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

#### 상태 코드 - 100-199(정보성 상태 코드)
- 정보성 상태 코드는 HTTP/1.1에서 도입되었다.
- 100 Continue 상태 코드는 약간 혼란스럽다. 100 Continue는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아 들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입 된 것이다.

#### 상태 코드 - 클라이언트와 100 Continue
- 만약 클라이언트가 엔터티를 보내지 않으려 한다면, 100-continue Expect 헤더를 보내지 않아야 한다.
- 왜냐하면 이것은 클라이언트가 엔터티를 보낼 것이라고 생각하게 만들어 서버를 혼란에 빠뜨릴 뿐이기 때문이다.
- 100-coutinue는 여러 측면에서 최적화를 위한 것이다. 클라이언트 애플리케이션은 100-continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다.
- 서버가 100 Continue 응답을 보내주기를 막연히 기다리기만 해서는 안된다. 약간의 타임아웃 후에 클라이언트는 그냥 엔터티를 보내야 한다.
- 클라이언트 개발자는 예상하지 못한 100 Continue 응답에도 대비해야 한다.

#### 상태 코드 - 서버와 100 Continue
- 서버가 100-continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100 Continue 응답 혹은 에러 코드로 답해야 한다.
- 서버는 절대로 100-continue 응답을 받을 것을 의도하지 않은 클라이언트에게 100 Continue 상태 코드를 보내서는 안된다.
- 서버가 100 Continue 응답을 보낼 기회를 갖기 전에 어떤 이유로 인해 엔터티의 일부를 수신하였다면, 서버는 이 상태코드를 보낼 필요가 없다. (이미 클라이언트에서 엔터티를 보내고 있는 중이다.)
- 만약 서버가 100 continue 응답을 받을 것을 의도한 요청을 받고 난 상태에서 엔터티 본문을 읽기 전에 끝내기로 결정했다면 서버는 그냥 응답을 보내고 연결을 닫아서는 안된다.
- 클라이언트가 응답을 받을 수 없게 되기 때문이다.

#### 상태 코드 - 프락시와 100 Continue
- 클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시는 몇 가지 해야 할이 있다.
- 다음 홉(next-hop) 서버가 HTTP/1.1을 따르거나 혹은 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함시켜서 요청을 다음으로 전달해야 한다.
- 만약 다음 홉의 서버가 1.1보다 이전 버전의 HTTP를 따른다는 것을 알고 있다면, 프락시는 417 Expectation Faild 에러로 응답해야 한다.
- 프락시가 다음 홉 서버들에 대한 상태 몇 가지와 그들이 지원하는 HTTP 버전을 기억해둔다면, 100-continue 응답을 기대한 요청을 더 잘 다룰 수 잇게 되므로 프락시에게 이득이 된다.

#### 상태 코드 - 200-299(성공 상태 코드)
- 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.
    - ex) 200(OK), 201(Created), 202(Accepted), 203(Non-Authoritative Information), 204(No Content), 205(Reset Content), 206(Partial Content)

#### 상태코드 - 300-399(리다이렉션 상태 코드)
- 리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.
- 브라우저가 사용자를 귀찮게 하지 않고 알아서 새 위치로 이동할 수 있게 해준다.
- 리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.
    - ex) HTTP 애플리케이션은 그의 리소스에 대한 로컬 복사본이 여전히 최신인지 혹은 원래 서버에 있는 리소스가 수정되었는지 검사할 수 있다.(304)
- HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할때, 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다.
    - ex) 300(Multiple Choices), 301(Moved Permanently), 302(Found), 303(See Other), 304(Not Modified), 305(Use Proxy), 307(Temporary Redirect)
- 302, 303, 307 상태코드는 중복 되는 부분이 있으나 약간 미묘한 차이가 있다. HTTP/1.0과 HTTP/1.1에서 사용하는 상태코드가 다르다.
- HTTP/1.0
    - 클라이언트가 POST 요청을 보내고 리다이렉트 코드로 302를 사용한다.
- HTTP/1.1
    - 클라이언트가 POST 요청을 보내고 리다이렉트 코드로 303을 사용한다.
    - HTTP/1.1에서 302(임시 리다이렉트 URL을 보낼때 HTTP/1.0에서 사용하는 302와 다른 동작을 한다.)를 사용하게되면 303, 302에대한 혼동이 올 수 있기 때문에 HTTP/1.1에서는 302를 307로 대신해서 사용하고 있다.
- 서버는 리다이렉트 응답에 들어갈 가장 적절한 리다이렉트 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있다.

#### 상태코드 - 400-499(클라이언트 에러 상태 코드)
- 클라이언트는 서버가 다룰 수 없는 무엇인가를 보낸다. 잘못 구성된 요청 메시지 같은 것이 있을 수 있으며, 가장 흔한 것은 존재하지 않는 URL에 대한 요청이다.
    - ex) 400(Bad Request), 401(Unauthorized), 402(Payment Required), 403(Forbidden), 404(Not Found), 405(Method Not Allowed), 406(Not Acceptable), 407(Proxy Authentication Required), 408(Request Timeout), 409(Conflict), 410(Gone), 411(Length Required), 412(Precondition Failed), 413(Request Entity Too Large), 414(Request URI Too Long), 415(Unsupported Media Type), 416(Requested Range Not Satisfiable), 417(Expecation Failed)

#### 상태코드 - 500-599(서버 에러 상태 코드)
- 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다.
- 이것은 클라이언트가 서버의 제한에 걸린 것일 수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.
- 프락시는 클라이언트의 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 된다.
    - ex) 500(Internal Server Error), 501(Not Implemented), 502(Bad Gateway), 503(Service Unavailable), 504(Gateway Timeout), 505(HTTP Version Not Supported)

#### 헤더
- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.
- 헤더에는 특정 종류의 메시지에만 사용할 수 있는 헤더와, 더 일반 목적으로 사용할 수 있는 헤더, 그리고 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더가 있다.

#### 헤더 - 일반 헤더
- 일반 헤더는 클라이언트와 서버 양쪽 모두가 사용한다. 이들은 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.
    - ex) 메시지가 만들어진 일시

#### 헤더 - 요청 헤더
- 요청 헤더는 요청 메시지를 위한 헤더다.
- 그들은 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.
    - ex) Accept 헤더

#### 헤더 - 응답 헤더
- 응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.
    - ex) Server 헤더(클라이언트에게 그가 어떤 서버와 버전을 대화 하고 있는지 알려준다)

#### 헤더 - 엔터티 헤더
- 엔터티 헤더란 엔터티 본문에 대한 헤더를 말한다.
- 엔터티 헤더는 엔터티 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있다.
    - ex) Content-Type 헤더

#### 헤더 - 확장 헤더
- 확장 헤더는 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더다.

#### 일반 헤더
- 어떤 헤더는 메시지에 대한 아주 기본적인 정보를 제공한다. 이 헤더들은 일반 헤더라고 한다.

#### 일반 헤더 - 캐시 해더
- HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사복으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했다.

#### 요청 헤더
- 요청 헤더는 요청 메시지에서만 의미를 갖는 헤더다.
- 그들은 요청이 최초 발생한 곳에서 혹은 무엇이 그 요청을 보냈는지에 대한 정보나 클라이언트의 선호나 능력에 대한 정보를 준다.

#### 요청 헤더 - Accept 관련 헤더
- 클라이언트는 Accept 관련 헤더들은 이용해 서버에게 자신의 선호와 능력을 알려 줄 수 있다.
- 클라이언트가 무엇을 원하고 무엇을 할 수 있는지, 그리고 무엇보다도 원치 않는 것은 무엇인지 알려줄 수 있다.

#### 요청 헤더 - 조건부 요청 헤더
- HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다.
- 그것은 요청하는 클라이언트가 어느 정도의 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 약간 더 안전하게 만들고자 한다.

#### 요청 헤더 - 요청 보안 헤더
- HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다
- 그것은 요청하는 클라이언트가 어느 정도의 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 약간 더 안전하게 만들고자 한다.

#### 요청 헤더 - 프락시 요청 헤더
- 인터넷에서 프락시가 점점 흔해지면서, 그들의 기능을 돕기 위해 몇몇 헤더들이 정의되어 왔다.

#### 응답 헤더
- 응답 메시지는 그들만의 응답 헤더를 갖는다. 응답 헤더는 클라이언트에게 부가 정보를 제공한다.

#### 응답 헤더 - 협상 헤더
- 서버에 프랑스어와 독일어로 번역된 HTML 문자가 있는 경우와 같이 여러 가지 표현이 가능한 상황이라면, HTML/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인가에 대한 협상을 할 수 있도록 지원한다.

#### 응답 헤더 - 응답 보안 헤더
- 기본적으로 HTTP 인증요구/응답 체계에서 응답 측에 해당하는 요청 보안 헤더는 요청 헤더의 요청 보안 헤더와 거의 동일하다.

#### 엔터티 헤더
- HTTP 메시지의 엔터티에 대해 설명하는 헤더들은 많다.
- 요청과 응답 양쪽 모두 엔터티를 포함할 수 있기 때문에, 이 헤더들은 양 타입의 메시지에 모두 나타날 수 있다.
- 엔터티 헤더는 엔터티와 그것의 내용물에 대한, 객체의 타입부터 시작해서 주어진 리소스에 대해 요청할 수 있는 유요한 메서들까지, 광범위한 정보를 제공한다.

#### 엔터티 헤더 - 콘테츠 헤더
- 콘텐츠 헤더는 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다.
- 콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있는 것들이다.
    - ex) Content-Type 헤더

#### 엔터티 헤더 - 엔터티 캐싱 헤더
- 일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지에 대한 지시자를 제공한다.
- 엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공한다.
    - ex) 리소스에 대해 캐시된 사본이 아직 유효한지에 대한 정보와, 캐시된 리소스가 더 이상 유효하지 않게 되는 시점을 더 잘 추정하기 위한 단서 같은 것이다.

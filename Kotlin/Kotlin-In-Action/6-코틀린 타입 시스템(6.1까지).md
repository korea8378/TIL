# Kotlin-In-Action

## 09월 24일

### 6.코틀린 타입 시스템

#### 널 가능성
- 널 가능성은 NullPointerException 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.
- 코틀린을 비롯한 최신언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행시점에서 컴파일 시점으로 옮기는 것이다.
- 널이 될 수 있는지 여부를 타입 시스템에 추가함로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생 할 수 있는 예외의 가능성을 줄일 수 있다.

#### 널이 될 수 있는 타입
- 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점이다.
- 널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에 null을 허용하게 만드는 방법이다.
- 어떤 변수가 널이 될 수 있다면 그 변수에 대해 메소드를 호출하면 NullPointerException이 발생할 수 있으므로 안전하지 않다.
- 코틀린은 그런 메소드 호출을 금지
- 컴파일러는 널이 될 수 있는 값을 인자로 넘기지 못하게 막는다.
<pre><code>
//널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표(?)를 명시
fun strLenSafe(s: String?) = …

//널이 될 수 있는 타입인 변수에 대해 변수.메소드()처럼 메소드를 직접 호출할수는 없다.
fun strLenSafe(s: String?) = s.length()

//널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.
val x: String? = null
var y: String = x

//널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.
strLen(x)
</code></pre>
- 어떤 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다.
- 제약이 많지만 사용하는 이유는 대표적으로 null과 비교하는 것이다.
<pre><code>
fun strLenSafe(s: String?): Int =
	if (s != null) s.length else 0
</code></pre>
- 코틀린은 널이 될 수 있는 값을 다룰 때 도움이 되는 여러 도구를 제공한다.

#### 타입의 의미
- 타입
    - 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정
- 자바에서는 null이 들어있는 경우에는 사용할 수 있는 연산이 많지 않다.
- 자바의 타입 시스템이 널을 제대로 다루지 못한다는 뜻이다.
- 코틀린의 널이 될 수 잇는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.
- 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분
- NullPointerException이 발생하는 연산을 아예 금지 시킬 수 있다.

#### 안전한 호출 연산자(?.)
- ?.은 null검사와 메소드 호출을 한 번의 연산으로 수행된다.
- null이 아니라면 ?.은 일반 메소드 호출처럼 작동한다.
- null이면 호출은 무시되고 null이 결과 값이 된다.
<pre><code>
class Address(val streetAddress: String, val zipCodeL Int,
			val city: String, val country: String)
class Company(val name: String, val address: Address?)
class Person(val name: String, val company: Company?)
fun Person.countryName(): String {
	val country = this.company?.address?.country
	return if (country != null) country else “Unknown”
}
</code></pre>
- 객체 그래프에서 널이 될 수 있는 중간 개체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편할 때가 자주 있다.
- 널 검사가 들어간 호출이 연달아 있는 경우를 자바 코드에서 자주 볼 수 있다.
- 코틀린에서는 훨씬 간결하게 널 검사를 할 수 있다.

#### 엘비스 연산자(?:)
- null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공한다.
- 엘비스 연산자는 ?:로 사용한다.
- 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.
<pre><code>
fun strLenSafe(s: String?) : Int = s?.length ?: 0
</code></pre>
- 코틀린에서는 return이나 throw 등의 연산도 식이다.
- 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고 엘비스 연산자를 더욱 편하게 사용할 수 있다.
- 그런 경우 엘비스 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다. 이런 패턴은 함수의 전제 조건을 검사하는 경우 특히 유용하다.
<pre><code>
class Address(val streetAddress: String, val zipCodeL Int,
			val city: String, val country: String)
class Company(val name: String, val address: Address?)
class Person(val name: String, val company: Company?)
fun printShippingLabel(person: Person) {
	val address = person.company?.address
		?: throw IllegalArgumentExcetpion(“No address”)
	with (address) {
		println(streetAddress)
		println(“$zipcode $city, $country”)
	}
}
</code></pre>

#### 안전한 캐스트(as?)
- 자바 타입 캐스트와 마찬가지로 대상 값을 as로 지정한 타입으로 바꿀 수 없으면 ClassCastException이 발생한다.
- 안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.
<pre><code>
class Person(val firstName: String, val lastName: String) {
	override fun equals(o: Any?) : Boolean {
		val otherPerson = o as? Person ?: return false
		
		return otherPerson.firstName == firstName &&
			otherPerson.lastName == lastName
	}
	
	override fun hashCode() : Int =
		firstName.hashCode() * 37 + lastName.hashCode()
}
</code></pre>

#### 널 아님 단언(!!)
- 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 잇는 도구 중에서 가장 단순하면서도 무딘 도구다
- 근본적으로 !!는 컴파일러에게 “나는 이 값이 null이 아님을 잘 알고 있다. 내가 잘 못 생각했다면 예외가 발생해도 감수하겠다”라고 말하는 것이다.
- 호출된 함수가 언제나 다른 함수에서 널이 아닌 값을 전달받는다는 사실이 분명하다면 굳이 널 검사를 다시 수행하고 싶지 않을 것이다.
- 이럴 때 널 아님 단언문을 쓸 수 있다.
<pre><code>
class CopyRowAction(val list: JList<String>) : AbstractAction() {
	override fun isEnabled() : Boolean =
		list.selectedValue != null
	override fun actionPerformed(e: ActionEvent) {
		val value = list.selectedValue!!
	}
}
</code></pre>
- 함정
    - !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.

#### let 함수
- let 함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다.
- let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.
- let 함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다. 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 전달한다.
- let을 안전하게 호출하면 수신 객체가 널이 아닌 경우 람다를 실행해준다.
<pre><code> fun sendEmailTo(email: String) {
	println(“Sending email to $email”)
}

var email: String? = “yole@example.com”
email?.let { sendEmailTo(it) }
</code></pre>
- let을 쓰면 긴 식의 결과를 저장하는 변수를 따로 만들 필요가 없다.
- 여러 값이 널인지 검사해야 한다면 let 호출을 중첩시켜서 처리할 수 있다.
- 그렇게 중첩시켜 처리하면 코드가 복잡해져서 알아보기 어려워진다.
- 그런 경우 일반적인 if를 사용해 모든 값을 한꺼번에 검사하는 편이 낫다.

#### 나중에 초기화할 프로퍼티
- 코틀린에서는 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수는 없다.
- 프로퍼티 타입이 널이 될 수 없는 타입이라면 반드시 널이 아닌 값으로 그 프로퍼티를 초기화해야 한다.
- 그런 초기화 값을 제공할 수 없으면 널이 될 수 있는 타입을 사용할 수 밖에 없다.
- But 널이 될 수 있는 타입을 사용하면 모든 프로퍼티 접근에 널 검사를 넣거나 !! 써야 한다.
- 나중에 초기화
    - lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.
<pre><code>
//null 체크
class MyService {
	fun performAction() : String = “foo”
}

class MyTest {
	private var myService: MyService? = null
	@Before fun setUp() {
		myService = MyService()
	}

	@Test fun testAction() {
		Assert.assertEquals(“foo”,
		myService!!.performAction())
	}
}

//lateinit 변경자 사용(null 체크 x)
class MyService {
	fun performAction() : String = “foo”
}

class MyTest {
	private lateinit var myService: MyService
	@Before fun setUp() {
		myService = MyService()
	}

	@Test fun testAction() {
		Assert.assertEquals(“foo”,
		myService.performAction())
	}
}
</code></pre>
- 나중에 초기화하는 프로퍼티는 항상 var여야 한다. val는 final이기 때문에 생성자를 이용한 초기화를 해야하기 때문에
- 프로퍼티를 초기화하기 전에 프로퍼티에 접근하면 “lateinit property myService has not been initialized”이라는 예외가 발생한다.

#### 널이 될 수 있는 타입 확장
- 널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.
- 수신 객체에 대해 호출할 수 있는 isNullOrEmpty이나 isNullOrBlank 메소드가 있다.
<pre><code>
// 널이 될 수 있는 타입의 확장 함수
fun verifyUserInput(input: String?) {
	if (input.isNullOrBlank()) {
		println(“Please fill in the required fields”)
	}
}

fun String?.isNullOrBlank() : Boolean = 
	this == null || this.isBlank()
</code></pre>
- isNullOrBlank는 널을 명시적으로 검사해서 널인 경우 true를 반환하고, 널이 아닌 경우 isBlank를 호출
- 자바에서는 메소드 안의 this는 그 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다. 코틀린에서는 널이 될 수 있는 타입의 확장 함수 안에서는 this가 널이 될 수 있다는 점이 자바와 다르다.

#### 확장함수 작성 팁
- 직접 확장 함수를 작성한다면 그 확장 함수를 널이 될 수 있는 타입에 대해 정의할지 여부를 고민할 필요가 있다.
- 처음에는 널이 될 수 없는 타입에 대한 확장함수를 정의하라. 나중에 대부분 널이 될 수 있는 탕비에 대해 그 함수를 호출했다는 사실을 깨닫게 되면 확장 함수 안에서 널 을 제대로 처리하게 하면 안전하게 그 확장함수를 널이 될 수 있는 타입에 대한 확장함수로 바꿀 수 있다.

#### 타입 파라미터의 널 가능성
- 널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신할 수 있다.
- 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다.
<pre><code>
// T는 널이 될 수 도 있다.
fun <T> printHashCode(t: T) {
	println(t?.hashCode())
}

// T는 널이 될 수 없다.
fun <T: Any> printHashCode(t: T) {
	println(t?.hashCode())
}
</code></pre>
- 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한를 지정해줘야 한다.
- 타입 파리미터는 널이 될 수 있는 타입을 표시하려면 반드시 물음표를 타입 이름뒤에 붙여야 한다는 규칙의 유일한 예외다.

#### 널 가능성과 자바
- 자바 타입 시스템은 널 가능성을 지원하지 않는다.
- 자바 코드에도 애노테이션으로 표시된 널 가능성 정보가 있다.
- 따라서 자바의 @Nullable String은 코트린 쪽에서 볼 때 String?와 같고, 자바의 @NotNull String은 코트린쪽에서 볼 때 String과 같다.

#### 플랫폼 타입
- 플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
- 그 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.
- 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 개발자에게 있다는 뜻이다.
- 실제로 코틀린 컴파일러는 골개 가시성인 코틀린 함수의 널이 아닌 타입인 파라미터와 수신 객체에 대한 널 검사를 추가해준다.
- 따라서 공개 가시성 함수에 널 값을 사용하면 즉시 예외가 발생한다. 이런 파라미터 값 검사는 함수 내부에서 파라미터를 사용하는 시점이 아니라 함수 호출 시점에 이뤄진다.
- 자바 API를 다룰 때는 조심해야 한다. 대부분의 라이브러리는 널 관련 애노테이션을 쓰지 않는다. 오류를 피하려면 사용하려는 자바 메소드의 문서를 자세히 살펴봐서 그 메소드가 널을 반환할지 알아내고 널을 반환하는 메소드에 대한 널 검사를 추가해야한다.
- 코틀린에서 플랫폼 타입을 선언할 수는 없다. 자바 코드에서 가져온 타입만 플랫폼 타입이 된다.
- String! 타입의 널 가능성에 대해 아무 정보도 없다는 뜻이다.
- 플랫폼 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입 어느 쪽으로든 사용할 수 있다.

#### 상속
- 코틀린에서 자바 메소드를 오버라이드할 때 그 메소드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야한다.
- 자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.



# Kotlin-In-Action

## 09월 19일

### 람다로 프로그래밍

#### 람다식
- 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻 한다.
- 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아낼 수 있다.
- ex) 컬렉션 처리

#### 람다
- 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우
- 자바에서는 무명 내부 클래스를 통해 이런 목적을 달성
- 무명 내부 클래스를 일일이 만들어야하는 번거러움이 동반된다.
- 함수형 프로그래밍
  - 함수를 값처럼 다루는 접근 방법을 택함으로써 이 문제를 해결
  - 클래스를 성넌하고 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 직접 다른 함수에 전달
  - 람다 식을 사용하면 코드가 더욱더 간결해진다.
  - 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달

#### 람다와 컬렉션
- 코드에서 중복을 제거하는 것은 프로그래밍 스타일을 개선하는 중요한 방법 중 하나다.
<pre><code>
fun findTheOldest(people: List<Person>) {
	var maxAge = 0
	var theOldest: Person? = null
	for (person in people) {
		if (person.age > maxAge) {
			maxAge = person.age
			theOldest = person
		}
	}
	println(theOldest)
}

// kotlin lambda(라이브러리 함수)
people.maxBy(person::age)
</code></pre>
- maxBy는 가장 큰 원소를 찾기 위해 비교에 사용할 값을 돌려주는 함수를 인자로 받는다.
- 람다나 멤버 참조를 인자로 받는 함수를 통해 개선한 코드는 더 짧고 더 이해하기 쉽다.

#### 람다 식의 문법
- 코틀린 람다 식은 항상 중괄호로 둘러싸여 있다. 인자 목록 주변에 괄호가 없다는 사실을 꼭 기억하자
- 화살표(->)가 인자 목록과 람다 본문을 구분해준다.
- 람다 식을 변수에 저장할 수 있다.
- 코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다.
- 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출시 빈 괄호를 없애도 된다.
<pre><code>
people.maxBy({ p: Person -> p.age })
//인자가 람다일 경우 외부로 뺄 수 있다. 
people.maxBy() { p: Person -> p.age }
//괄호 생략 가능(람다가 유일한 인자 일 경우)
people.maxBy { p: Person -> p.age }
</code></pre>
- 람다가 함수의 유일한 인자라면 괄호 없이 람다를 쓰기를 원하게 될 것이다.
- 인자가 여럿 있는 경우에는 람다를 밖으로 빼낼 수도 있고 람다를 괄호 안에 유지해서 함수의 인자임을 분명히 할 수도 있다.
- 이름 붙은 인자를 사용해 람다를 넘김으로써 람다를 어떤 용도로 쓰는지 더 명확히 할 수 있다.
<pre><code>
// 람다를 이름 붙은 인자로 명시
val names =people.joinToString(separator = “ “, transform = { p: Person -> p.name } )
//파라미터 타입을 생략
people.maxBy { p -> p.age }
//디폴트 파라미터 이름 it
people.maxBy { it.age }
</code></pre>
- 로컬 변수처럼 컴파일러는 파라미터의 타입도 추론할 수 있다.
- 파라미터 타입을 명시할 필요가 없다
- maxBy 함수의 경우 파라미터의 타입은 항상 컬렉션 원소 타입과 같다.
- 컴파일러가 람다 파라미터의 타입을 추론하지 못하는경우도 있다.
- 람다의 파라미터 이름을 디폴트 이름인 it으로 바꾸면 람다 식을 더 간단하게 만들 수 있다.
- 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it을 바로 쓸 수 있다.

#### 변수에 접근
- 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.
- 자바와 다른 점 중 중요한 한 가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 점이다.
- 코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있었다.
- 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다.
- 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 일거나 쓸 수 있다.
- 파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장한다.
- 파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.
- 함정
    - 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드를 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다.
<pre><code>
//코틀린 람다에서는 로컬변수 값을 변경이 가능하다.
fun printProblemCounts(response: Collection<String>) {
	var clientErros = 0
	var serverErros = 0
	responses.forEach {
		if (it.startsWith(“4”)) {
			clientErros++
		} else if (it.startsWith(“5”)) {
			serverErros++
		}
	}
	println(“$clientErros client erros, $serverErros server erros”)
}
</code></pre>

#### 멤버 참조
- 코틀린에서는 자바 8과 마찬가지로 함수를 값으로 바꿀 수 있다. 이때 이중 콜론을 사용한다.
- ::를 사용하는 식을 멤버 참조라고 부른다. 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다.
- 참조 대상이 함수인지 프로퍼티인지와는 관계없이 멤버 참조 뒤에는 괄호를 넣으면 안된다.
- 최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다.
<pre><code>
//아래의 세개의 코드는 동일한 동작을 한다.
people.maxyBy(Person::age)
people.maxBy { p -> p.age }
people.maxBy { it.age }

//최상위 함수도 참조가 가능하다.
fun salute() = println(“Salute!”)
run(::salute)

//생성자 참조
data class Person(val name: String, val age: Int)
val createPerson = ::Person
val p = createPerson(“Alice”, 29)
println(p)
</code></pre>
- 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장 해둘 수 있다.

#### 컬렉션 함수형 API
- 함수형 프로그래밍 스타일을 사용하면 컬렉션을 다룰 때 편리하다.
- 라이브러리 함수를 활용할 수 있고 그로 인해 코드를 아주 간결하게 만들 수 있다.
- ex) filter, map
- 컬렉션을 다루는 코드를 작성할 경우에는 원하는 바를 어떻게 일반적인 변환을 사용해 표현할 수 있는지 생각해보고 그런 변환을 제공하는 라이브러리 함수가 있는지 살펴보자

#### filter와 map
- 컬렉션을 활용할 때 기반이 되는 함수다.
- 대부분의 컬렉션 연산을 이 두 함수를 통해 표현할 수 있다.
- filter함수
    - 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다.
    - retrun 으로는 새로운 컬렉션이 만들어진다.
    - fileter는 원소를 변환 할 수는 없다.
- map함수
    - 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.
<pre><code>
val list = lisOf(1, 2, 3, 4)
println(list.filter { it % 2 == 0 })
println(list.map { it * it })
</code></pre>
- 꼭 필요하지 않은 경우 굳이 계산을 반복하지 말자!!
- 람다를 인자로 받는 함수에 람다를 넘기면 겉으로 볼 때는 단순해 보이는 식이 내부 로직의 복잡도로 인해 실제로는 엄청나게 불합리한 계산식이 될때가 있다.

#### all, any, count, find
- 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산
- all 함수
    - 모든 원소가 술어(람다 or 조건)에 만족하는지
- any 함수
    - 술어를 만족하는 원소가 하나라도 있는지
- !를 통한 부정으로 응용해서도 사용할 수 있다.
    - ex) !all, !any
- 가독성을 높이려면 any와 all 앞에 !를 붙이지 않는 편이 낫다.
<pre><code>
val canBeInClub27 = { p: Person -> p.age <= 27 }
val people = listOf(Person(“Alice”, 27), Person(“Bob”, 31))
println(people.all(canBeInClub27))
println(people.any(canBeInClub27))
</code></pre>
- count 함수
    - 술어를 만족하는 원소의 개수를 구할 때
- find 함수
    - 만족하는 원소가 하나라도 있는 경우 가장 먼저 조건을 만족한다고 확인 원소를 반환
    - find는 firstOrNull과 같다.
    - 조건을 만족하는 원소가 없으면 null이 나온다는 사실을 더 명확히 하고 싶다면 firstOrNull을 쓸 수 있다.

#### groupBy
- 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 함수
- groupBy의 결과 타입은 Map<Int, List<Person>>이다.
- 필요하면 맵을 mapKeys나 mapValues 등을 사용해 변경할 수 있다.
<pre><code>
val list = listOf(“a”, “ab”, “b”)
println(list.groupBy(String::first))
</code></pre>
 
#### flatMap과 flatten
- flatMap 함수
    - 먼저 인자로 주어진 람다를 컬렉션의 모든 객체 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.
    - 리스트의 리스트가 있는데 모든 중첩된 리스트의 원소를 한 리스트로 모아야 할 때
- flatten
    - 특별히 변환해야 할 내용이 없다면 리스트의 리스트를 평평하게 펼치기만 하면 된다면 flatten 함수를 사용
<pre><code>
val books = listOf(Book("Thursday Next", listOf("Jasper Fforde")),
				Book("Mort", listOf("Terry Pratchett")),
				Book("Good Omens", listOf("Terry Pratchett",
										"Neil Gaiman")))
println(books.flatMap { it.authors }.toSet())
</code></pre>
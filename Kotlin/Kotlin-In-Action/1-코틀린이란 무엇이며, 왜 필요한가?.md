# Kotlin-In-Action

## 09월 09일

### 1. 코틀린이란 무엇이며, 왜 필요한가?

#### 코틀린은 무엇인가?
- 코틀린은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어이다.
- 코틀린은 간결하고 실용적이며, 자바 코드와의 상호운용성을 중시한다.
- 기존 자바 라이브러리나 프레임워크와 함께 잘 작동하며, 성능도 자바와 같은 수준이다.

#### 정적 언어
- 코틀린은 정적언이다.
- 타입 추론
    - 하지만 타입 추론 기능이 있어 컴파일러가 문맥을 고려해 변수 타입을 결정하는 기능을 가지고 있다.

#### 정적 타입 지정의 장점
- 성능
    - 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠르다.
- 신뢰성
    - 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
- 유지 보수성
    - 코드에서 다루는 객체가 어던 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 도구 지원
    - 정적 타입 지정을 활용하면 더 안전하게 리팩토링 할 수 있고, 도구는 더 정확한 코드와 완성 기능을 제공할 수 있으며, IDE의 다른 지원 기능도 더 잘 만들 수 있다.

#### 널 포인터 예외
- 코틀린은 널이 될 수 있는 타입을 지원한다.
- 널이 될 수 잇는 타입을 지원함에 따라 컴파일 시점에 널포인터 예외가 발생할 수 있는지 여부를 검사할 수 있어서 좀 더 프로그램의 신뢰성을 높일 수 있다.

#### 함수 타입
- 코틀린의 타입 시스템에 있는 다른 새로운 내용으로는 함수 타입에 대한 지원을 들 수 있다.

#### 함수형 프로그래밍
- 일급 시민인 함수 
    - 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
- 불변성
    - 함수형 프로그래밍에서는 일단 만들어지고 나면 내부상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다.
- 부수 효과 없음
    - 함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.

#### 함수형 프로그래밍의 장점
- 간결성(람다식/명령형)
- 다중 스레드를 사용해도 안전(불변성)
- 테스트 하기 쉽다.(부수 효과 없음)

#### 함수형 프로그래밍을 풍부하게 지원하는 코틀린
- 함수 타입을 지원함에 따라 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다.
- 람다 식을 지원함에 따라 번거로운 준비 코드를 작성하지 않아도 코드 블록을 쉽게 정의하고 여기저기 전달할 수 있다.
- 데이터 클래스는 불변적인 값 객체를 간편하게 만들 수 있는 구문을 제공한다.
- 코틀린 표준 라이브러리는 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공한다.

#### 코틀린 서버 프로그래밍
- 브라우저에 HTML 페이지를 돌려주는 웹 애플리케이션
- 모바일 애플리케이션에게 HTTP를 통해 JSON API를 제공하는 백엔드 애플리케이션
- RPC 플로토콜을 통해 서로 통신하는 작은 서비스들로 이뤄진 마이크로서비스

#### 코틀린의 철학
- 실용성
    - 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다.
    - 언어의 복잡도가 줄어들고 이미 알고 있는 기존 개념을 통해 코틀린을 더 쉽게 배울 수 있다.
    - 특정 프로그래밍 스타일이나 패러다임을 사용할 것 을 강제로 요구하지 않는다.
    - IDE의 코틀린 언어 지원이 중요한 역할을 한다.(도구를 강조)
- 간결성
    - 코드가 더 간단하고 간결할수록 내용을 파악하기가 더 쉽다.
    - 프로그래머가 작성하는 코드에서 의미가 없는 부분을 줄이고, 언어가 요구하는 구조를 만족시키기 위해 별 뜻은 없지만 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 기울였다.(게터, 세터, 생성자 파라미터와 같이 여러가지 번거로운 준비코드를 묵시적으로 제공해준다.)
    - 컬렉션에서 원소를 찾는 것과 같은 일반적인 작업을 수행하기 위해 명시적으로 작성X(라이브러리 함수 호출로 대치)
    - 코틀린은 연산자 오버로딩을 지원하지만, 언어가 제공하지 않는 연산자를 프로그래머가 정의할 수 있게 허용하지 않는다.
- 안정성
    - 프로그램에서 발생할 수 있는 오류 중에서 일부 유형의 오류를 프로그램 설계가 원천적으로 방지(이는 절대적이지는 않다.)
    - 더 큰 안전성을 얻기 위해서는 프로그램에 더 많은 정보를 덧붙여야 하므로 생산성이 하락하는 것을 감수해야하며 안전성과 생산성 사이에는 트레이드오프 관계가 성립
    - JVM
        - JVM을 사용하면 메모리 안전성을 보장하고, 버퍼 오버플로를 방지하며, 동적으로 할당한 메모리를 잘못 사용함으로 인해 발생할 수 있는 다양한 문제를 예방
    - 코틀린 컴파일러가 타입을 자동으로 추론해주기 때문에 개발자가 직접 타입 정보를 지정할 필요가 없다.
    - 코틀린은 NullPointerException을 없애기 위해 노력한다.
        - 코틀린의 타입 시스템은 null이 될수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 사용하는 코드를 금지한다.
    - ClassCastException
        - 어떤 객체를 다른 타입으로 캐스트하기 전에 타입을 미리 검사하지 않으면 ClassCastException이 발생할 수도 있다.
- 상호운용성
    - 코틀린과 자바를 함께 사용 할 수 있다.
    - 라이브러리가 어떤 API를 제공하던 간에 코틀린에서 그 API(자바)를 활용할 수 있다.
    - 자바 메소드를 호출하거나 자바 클래스를 상혹 확장하거나 인터페이스를 구현 하거나 자바 애노테이션을 코틀린 코드에 적용하는 등의 일이 모두 가능하다.
    - 자바 코드에서 코틀린 코드를 호출할 때도 아무런 노력이 필요없다.(역으로 성립)
    - 자바와 코틀린 코드를 프로젝트에서 원하는 대로 섞어 쓸 수 있는 궁극적인 유연성을 발휘 가능하다.(전혀 수정하지 않고도 컴파일 및 실행이 가능하다.)
    - 코틀린은 기존 자바 라이브러리를 가능하면 최대한 활용한다.(코틀린은 자체 컬렉션 라이브러리를 제공하지 않는다. 몇 가지 기능을 더할 뿐)

#### 코틀린 컴파일러
- 코틀린 컴파일러는 자바컴파일러가 자바 소스코드를 컴파일할 때와 마찬기지로 코틀린 소스코드를 분석해서 .class 파일을 만들어 낸다.
- 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리를에 의존한다.
- 런타임 라이브러리에는 코틀린 자체 표준 라이브러리 클래스와 코틀린에서 자바 API의 기능을 확장한 내용이 들어 있다.
- 코틀린으로 컴파일한 애플리케이션을 배포할 때는 런타임 라이브러리도 함께 배포해야 한다.

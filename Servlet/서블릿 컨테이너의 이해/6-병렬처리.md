# 서블릿 컨테이너의 이해

## 2월 27일

### 6.병렬처리

#### stop/suspend와 wait/notify 메서드
- 성능을 높이기 위해 대기 상태의 스레드를 미리 여러 개 만들어 놓고 요청이 들어오면 활성화해 요청을 처리한 후, 다시 대기 상태로 관리하고 있습니다.
- 자바 스레드 API에는 stop/suspend 메서드가 있지만 모두 deprecated 되었습니다.

#### stop
- stop 메서드가 호출되면 해당 스레드가 즉시 멈춥니다. 그와 더불어 ThreadDeath 예외가 발생하면서 해당 스레드가 배타적으로 소유하던 모든 객체에 대한 모니터가 즉시 해제되어 다른 스레드가 접근할 수 있게 됩니다.
- 문제는 소유하던 객체의 상태가 불안정한 상태일 수도 있다는 것입니다. 스레드가 특정 객체에 모니터 잠금을 사용하는 이유는 다른 스레드가 접근하지 못하게 배타적인 권한을 획득한 후 객체의 내부 상태를 변경하기 위해서입니다.
- 그런데 스레드가 객체의 상태를 변경하던 중 stop 메서드가 호출되면 외부 스레드에 모순된 상태의 객체, 즉 상태 변경이 완료되기 전의 형상에 접근할 수 있어 원인을 매우 찾기 어려운 버그가 됩니다.

#### suspend
- 스레드가 특정 리소스에 대한 뮤택스를 획득한 상태에서 suspend 메서드가 호출돼 정지되면, 리스소에 접근하려는 스레드는 suspend된 스레드가 스스로 동작을 재개해 뮤택스를 풀기전까지 기약 없이 대기해야하는 문제가 발생합니다.
- 이런 시나리오는 데드락이 발생할 수 있는 대표적인 예입니다.

#### wait/notify
- 스레드를 대기키거나 진행하려면 wait/notify를 이용해야 한다.
- 톰캣에서 4.x에서 제공하던 스레드 풀은 가 스레드에 lock 객체를 생성하고 해당 객체에 대해 wait 메서드를 호출함으로써 스레드를 대기 상태로 유지했습니다.
- 이런 대기 상태에 있는 스레드드를 리스트 형태로 유지하다가 요청이 들어오면 스레드를 대기 리스트에서 빼내 서블릿 실행에 필요한 정보를 전달합니다.
- 그다음 해당 스레드를 대기 상태에서 활성화 상태로 바꾸기 위해 notify 메서드를 호출합니다. 이 때 스레드는 정지됐던 wait 메서드 이후로 진행을 재개합니다.
- 서블릿 동작이 완료되면 스레드의 wait 메서드가 다시 호출되어, 스레드는 대기 상태로 돌아가며 다음 요청에 재사용할 수 있게 스레드는 대기 상태의 스레드 리스트로 재진입합니다.
- 이렇게 스레드마다 내부 lock을 사용해 개별적으로 대기를 구현하는 방법은 가장 직관적인 방식으로 스레드 풀링을 구현했다고 할 수 있습니다.

#### Concurrent Queue
- 스레드를 먼저 다수 생성한 후 단일 Concurrent Queue를 사용해 각 스레드가 take 메서드를 호출해 스레드를 간접적으로 대기하는 좀 더 단순한 방법입니다.
- 이 방법은 대기 리스트에 스레드를 유지, 관리할 필요가 없으며 단순히 요청을 Concurrent queue에 넣으면 queue.take 메서드에서 대기하던 스레드 중 하나가 동작합니다. 비교적 단순한 구조라는 것이 가장 큰 장점입니다.

#### 스레드 풀 구현시 고려사항
- 첫 번째, 스레드 풀로 관리하는 스레드는 한번 수행되고 버려지는 것이 아니라 반복적으로 재사용 가능해야 합니다. 따라서 스레드 풀 내에서 생성/관리되는 스레드는 한 번 수행됐다고 종료돼서는 안됩니다.
- 두 번째, busy wait를 통한 상태 체크는 안됩니다. 이를 막으려면 요청을 기다리면서 스레드 실행을 대기(wait 메서드)해야합니다. 새로운 요청이 들어왔을때, 즉시 작업을 할당할 수 있는 메서드(notify 메서드)를 만듭니다.
- 세 번째, 병렬로 실행하려는 특적한 Thread 객체에 어떻게 전달하는냐는 것입니다. 다시 말해, HTTP를 처리하는 클래스 X를 병렬로 수행하고자 할 때 단순히 스레드 풀이 Thread 클래스의 인스턴스를 가지고 해당 클래스를 어떻게 동작시킬 것인가 하는 문제입니다.(객체 지향언어에서 발생하는 대부분의 문제가 그렇듯 이것 역시 인터페이스를 사용해 해결합니다.)
- 추가 사항
    - 최대 가능 스레드 수, 최소 스레드 수, 저부하 상태에서 유지할 적절한 스레드 수와 같이 상태를 관리하는 기능이 추가돼야 합니다.
    - 또한, 지나치게 오랜 시간 동안 동작하는 스레드의 동작 시간을 체크하여 종료하는 기능도 필요합니다.
    - 스레드 풀 내부에 관리를 위한 스레드를 두어 위에서 언급한 정리작업을 따로 해야 합니다.

#### java.util.concurrent 패키지
- 스레드 풀 구현의 가장 큰 문제는 병렬처리 자체가 그렇게 호락호락 한 분야가 아니라는 것입니다.
- 일단 스레드를 적절히 생성하고 수행하는 생명주기를 관리해야 할 뿐만 아니라, 병렬 진행되는 스레드 간에 동시성 문제가 발생하지 않게 조절하는 것은 쉽지 않습니다.
- 또한, 스레드와 같은 병렬 진행을 다루는 프로그래밍은 순차진행 프로그래밍보다 디버깅 난이도가 급격하게 증가하므로 완성도 높은 구현체를 만드는 것은 아주 어려운 작업이라고 할 수 있습니다.
- 이런 어려움을 해결하기 위해서는 java 1.5에는 java.util.concurrent 패키지가 추가 되었습니다.
- ThreadPoolExceutor라는 스레드 풀 구현체가 추가 되었습니다. 현재 대부분 서블릿 컨테이너들은 ThreadPoolExceutor를 사용하거나 ThreadPoolExceutor와 인터페이스를 맞춘 구현체를 사용하고 있습니다.
- BlockingQueue(작업 큐)
    - SynchronousQueue
        - 수행 요청이 들어오면, 요청을 쌓아두지 않고 풀 내에 준비된 스레드를 즉시 매치하여 처리합니다. 따라서 스레드 풀 내에 준비된 스레드가 모두 다른 일을 수행 한다면, 최대 가능 스레드 수가 초과되지 않는 한 즉시 새 스레드를 생성해 요청을 처리합니다.
        - 최대 가능 스레드 이상의 요청이 들어오면 해당 요청은 버려지므로 최대 가능 스레드 수는 제한이 없게 크게 설정하는 것이 일반적입니다.
    - LinkedBlockingQueue
        - corePoolSize 수만큼만 스레드 사용해 동작하며, 이상의 요청이 들오면 스레드의 수를 늘리는 대신 추가 요청을 작업 큐에 쌓아 놓고 처리합니다. 
        - 작업큐에 제한이 없는 큐
        - 작업큐에 제한이 없기 때문에 큐의 크기가 비정상적으로 커지는 문제가 발생할 수 있습니다.
    - ArrayBlokcingQueue
        - corePoolSize 수만큼만 스레드 사용해 동작하며, 이상의 요청이 들오면 스레드의 수를 늘리는 대신 추가 요청을 작업 큐에 쌓아 놓고 처리합니다. 
        - 작업큐에 제한이 있는 큐
        - 미리 정해진 큐 사이즈를 넘는 요청을 모두 버립니다.

#### 적정 병렬 진행 수
- 대부분의 서블릿 컨테이너에는 서블릿을 동작시키는 스레드의 숫자를 설정할 수 있습니다.
- 다시 말해, 서블릿을 처리하기 위해 스레드 풀이 내부적을 유지하는 워크 스레드의 숫자를 지정할 수 있으며 이 값을 어떻게 설정하느냐에 따라 서블릿 컨테이너의 전체 처리량이 크게 영향을 받게 됩니다.

#### 스레드의 수에 대한 설정치를 구하기 위해 고려해야 할 사항
- 최대 스레드 수 설정은 CPU 코어 수보다 작지 않아야 합니다.
- 다수의 스레드가 소수의 CPU 코어를 이용하려면 특정 시간에는 반드시 하나 이상의 스레드가 CPU 코어를 점유하지 않고 대기 상태에 있어야 합니다. 
- 그러므로 처리하는 일이 CPU 연산 능력에만 의존하는 경우 CPU 코어 마다 하나의 스레드가 할당되게 설정하는 것이 최적입니다.

#### 병렬화 가능하지 않은 영역
- 병렬화되지 않는 구간이 존재할 수 있으며, 이런 구간이 전체 프로세스 중에 나타나는 위치와 빈도 따라 전체 병렬처리 효율은 크게 영향을 받게 됩니다.
- CPU 코어 수와 스레드 수를 일치시킬 때 최대 처리량을 얻을 것이라는 추측은 모든 CPU 코어를 최대한 동작시킬 방법이 있다는 가정하에서 설득력이 있으며, 이런 병렬화가 가능하지 않은 영역이 존재하는 경우 그 정당성을 상실합니다.

#### 병렬처리로 인해 부가되는 제약조건
- 선형적으로 팩토리얼 구하기 위해서는 단 2개의 저장소에 대한 접근, 즉 1씩 증가하는 현재 상태값과 지금까지의 상태값들을 곱해 온 중간 곱 결과값을 저장할 저장소와 저장소에 대한 접근이 필요합니다.
- 하지만 병렬처리를 위해서는 개별 스레드별로 부분 곱을 계산하기 위한 저장 장소를 따로 준비하여 접근하고 전체 곱을 구하기 위해 다시 한번 부분 곱의 배열에 접근하여 처리를 하게 됩니다.
- 다시 말해, 단순히 숫자들의 곱을 빨리 구하는 연산 능력이 유일한 성능 요소라고 가정할 수 없게 되었습니다.
- 서블릿 컨테이너의 최대 처리량에 대한 제약 조건이 CPU 처리량이 아니라 I/O 처리량이라는 사실을 기억하십시오.
- 그렇다면 가능한 동시에 많은 스레드를 사용해 I/O 처리량을 극대화하는 전략이 더 나은 선택이 될 수 있겟습니다. 하지만 무작정 스레드의 수가 많을수록 처리량이 늘어나지는 않습니다.
- 스레드도 생성하고 유지하는 관리에 비용이 드는 자원이기 때문입니다.
- 따라서 실직적으로 생성, 유지 가능한 스레드의 수는 제한적입니다.

#### 컨텍스트 스위칭
- 물리적인 제약 외에도 스레드의 수가 많아지면 그 자체가 성능 저하의 원인이 됩니다.
- CPU 코어 수 이상의 스레드는 동시에 활성화 되지 못하고 대기 상태에 머물러 있습니다.
- 시분할 기법
    - 하나의 프로세스와 스레드가 일정 시간 CPU를 사용한 후에는 다른 프로세스나 스레드에 사용을 양보한 후 대기하다가 자기 차례가오면, 앞서 수행한 단계 다음부터 진행을 계속 할 수 있어야 합니다.
- 양보의 시점에 수행하던 일의 차례, 계산해 놓았던 중간 결과물 등의 일 처리 문맥을 저장해 놓았다가 다시 자신의 차례가 오면 저장했던 정보에서 처리 문맥을 되돌리는 작업을 컨텍스트 스위칭이라고 합니다.
- 스레드의 수가 많아지면 CPU 점유에 대한 경쟁 조건이 심화되므로 자연히 컨텍스트 스위칭이 그만큼 더 자주 발생합니다.
- 그런데 컨텍스트 스위칭은 병렬로 처리되는 것처럼 보이게 하는 데 소요되는 비용이지 처리량을 높이는 것과는 무관합니다.
- 따라서 컨텍스트 스위칭의 발생을 억제할수록 성능이 개선됩니다. 이런 이유로 스레드의 개수는 특정한 한계가 분명히 있습니다.

#### 서블릿 컨테이너가 가져야 하는 스레드의 수는 얼마인가?
- 해당 사이트에서 사용하는 서블릿의 특성에 따라 좌우되므로 실제 상황에 맞게 설정 값을 적절히 변경해 가면서 최적의 값을 찾아내야 한다가 되겠습니다.
- 왜냐하면, 서블릿 컨테이너가 서비스하는 웹 사이트의 성능은 결국 서블릿 컨테이너 위에서 동작하는 서블릿이 어떤 성능을 가지는가에 가장 의존성이 높기 때문입니다.


# 서블릿 컨테이너의 이해

## 2월 14일

### 2.HTTP 프로토콜의 실제

#### HTTP 통신
- 웹 브라우저에서 도메인을 한번 호출 할 때를 주의 깊게 보자. 최종 사용자에게 하나로 보이는 요청을 처리하기 위해 웹 브라우저와 웹 서버 간에는 수 회에 걸친 통신이 발생할 수 있음을 보여 줍니다.
- 통신을 위해 사용하는 HTTP 프로토콜로 작성된 실제 데이터를 눈여겨보자.

#### HTTP 프로토콜의 간략한 소개
- 기술적인 측면에서 웹 서비스는 HTTP 프로토콜로 메시지를 전송하는 시스템이라 할 수 있습니다.
- 클라이언트가 보낸 메시지는 HTTP 프로토콜에 실려 서블릿 컨테이너에 전송됩니다.
- 전송된 메시지를 서버 측에서 재구성하려면 서블릿 컨테이너는 반드시 HTTP 프로토콜 해석 기계를 구현해야 합니다.

#### 하나의 HTTP 메시지를 특정하는 방법
- HTTP 프로토콜은 문서를 전송하는 단순한 형태에서 시작됐지만, 웹의 폭발적인 확대에 대응하기 위해 프로토콜 내용이 확장되면서 현재의 형태로 바뀌었습니다.
- 일관성이 부족한 부분
    - 하위 호환성을 유지하면서 기능을 추가하기 위해서는 불가피한 것이라 할 수 있습니다.

#### 어디가 메시지의 끝인가
- 컴퓨터 프로그램이 이런 모호함을 이해하고 통신할 수는 없습니다.
- 명확하고 일반적인 규약이 필요
    - 다음에 보낼 데이터의 크기를 미리 전송하여 수신측에게 어디까지 읽어야 하는지를 알려주는 방식과 종료 기호를 서로 약속한 후 해당 기호로 메시지의 끝을 표시하는 방식입니다.

#### Content-Length
- 앞으로 보낼 데이터의 크기를 미리 전송하는 방식은 말 그대로 먼저 보낼 데이터의 크기를 전송한 후, 전송한 크기만큼 데이터를 보내겠다고 약속하는 것

#### 종료기호 사용
- 어떤 문자를 사용할 것인가?
- 그문자를 인용하고 싶을때는 어떻게 처리할 것인가?
- 바이너리로 데이터를 보냈다면 어떻게 처리할 것인가?

#### HTTP 메시지의 크기를 미리 알 수 없는 경우
- Content-Length 헤더를 이용해 메시지 바디의 크기를 미리 알려주기 어려운 경우가 있습니다.
- HTTP 바디를 미리 모두 만든다는 것으로 이것은 명백히 서버 리소스를 낭비하게 됩니다.
- 응답이 오기 시작했다는 사실 자체가 최소한 자신이 보낸 요청이 서버 시스템에 전달돼 처리된다는 의미입니다.
- 청크 인코딩
    - 메시지 헤더에 transfer-coding 값으로 chunked를 지정하고 메시지 바디에 청크라는 단위의 데이터를 나열하는 방법

#### Connection
- Connection 헤더는 전송에 사용한 소켓 연결을 이번 요청/응답 전송이 완료된 이후 끊을 것인지 아니면 일정 시간 유지해 다음 요청에 대비 할것인지 여부를 지정하는 데 사용합니다.
- 앞선 요청에서 해당 헤더 값에 Keep-alive를 사용했습니다. 반면, 응답에서는 Connection 헤더 값이 close로 지정되었습니다.
- 따라서 요청에선 Keep-alive를 지정하고 소켓 연결을 유지할 것을 요구했더라도 서버에서 응답에 Connection:close를 지정하고 연결을 끊어버릴 수 있다는 점을 확인하십시오.

#### 정적 파일의 Connection을 유지 하지 않는 경우
- CSS 파일처럼 특정 사이트 내에서 반복적으로 사용되는 정적 파일의 경우, 웹 브라우저 캐시와 같은 클라이언트 사이드 캐시에 한 번 적재되면 다시 서버로 요청이 올 가능성이 낮습니다.
- 연결 하나에 요청/응답이 한 번만 수행되는 것이 대부분이라면, 가능한 요청처리 수는 서로 다른 클라이언트와의 연결 횟수에 비례해 증가할 것입니다.
- 그런데 서버가 동시에 사용할 수 있는 소켓 수는 한정되므로, 단위 시간내에 연결 횟수를 최대화하려면 각 소켓이 연결된 시간을 최소화해야 합니다.
- 따라서 한 번 수행된 연결을 서버에서 바로 연결을 끊어버리는 것이 더 낫습니다.

#### 파일 처리
- 서블릿 컨테이너는 서블릿이 InputStream의 일종인 ServletInputStream으로 HTTP 메시지 바디를 읽어들일 수 있게 합니다.
- 달리 말하면 Servlet 안에서 HttpServletRequest.getInputStream이라는 API로 웹 브라우저에서 넘어온 HTTP 메시지 바디의 내용을 바이트 단위로 읽어들일 수 있게 지원합니다.
- 서블릿 스펙 2.5까지는 멀티파트 폼 데이터를 지원하는 API가 없었습니다.
- 따라서 멀티파트 폼 데이터 형식의 HTTP 메시지 바디를 파싱하여 서블릿상에서 메모리상의 객체 형식의 접근을 가능하게 하는 공개/비공개 라이브러리가 여러 개 있습니다.
- 이런 라이브러리는 HTTP 헤더 값을 미리 읽어 Content-Type이 multipart/form-data인 경우 boundary 값을 알아낸 후 ServletInputStream으로 HTTP 바디를 읽어들입니다.
- 그다음 name/value쌍으로 해당 데이터를 메모리상에 올려 놓아 서블릿상에서 해당 라이브러리의 API를 사용해 접근할 수 있게 해 파일 업로드가 가능하도록 합니다.


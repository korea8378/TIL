# 서블릿 컨테이너의 이해

## 3월 3일

### 9.Comet - HTTP 알림

#### 왜 웹 환경에서는 서버와 연결된 사용자를 알 수 없는가?
- HTTP 프로토콜 자체 특성에 기인합니다.
- HTTP 프로토콜은 원래 문서를 요청하고 문서의 내용을 응답하는 목적으로 구상됐습니다.
- 따라서 클라이언트가 기존에 요청을 몇 번 했든 특정 문서에 대한 요청은 언제나 행당 문서의 내용이 반환돼야 합니다.
- 또한, 같은 문서에 대한 요청은 클라이언트에 상관없이 응답 내용이 같아야 합니다.
- 전송 이력과 전송 대상에 대한 정보는 응답 내용에 영향을 미치지 않으므로, 이를 유지할 이유가 없습니다.
- 따라서 HTTP 프로토콜은 웹 서버가 클라이언트를 특징지어 구별하는 방법을 제공하지 않습니다.
- 이것을 HTTP 프로토콜을 이용하는 웹의 한계 혹은 웹으로는 구현 불가 등으로 이야기되곤 했습니다.

#### 단순한 시도 - 폴링
- 주기적으로 화면을 새로고침 처리로 생각하시면 됩니다.
- 이 폴링 방식의 문제점은 사요자가 채팅 창을 열어 놓으면 새로운 메시지 추가 여부를 알기 위해 주기적으로 서버로 요청이 전달된다는 점에 있습니다.
- 특히 채팅처럼 전송 지연에 민감한 경우 그 주기를 길게 가져가기 어려워 다수의 사용자를 대상으로 이런 방식을 사용하기는 어렵습니다.

#### 생각의 전환 - 스트림 방식
- HTTP 프로토콜이 클라이언트에서 요청을 보내야 서버가 응답할 수 있는 구조라며, 다시말 해 서버가 클라이언트로 요청을 보낼 수 없고 응답만 보낼 수 있는 구조라면 서버가 응답을 주도적으로 보내는 전용 연결을 하나 더 생성/유지하는 것입니다.
- 주의 깊게 살펴볼 부분이 세가지
    - 1.서버가 즉각적으로 응답을 보내지 않는다는 점
        - 서버는 즉작적인 응답을 유보하고 TCP연결을 맺은 상태를 유지합니다.
        - 이후 서버가 클라이언트로 메시지를 전달할 때마다 미리 생성해 둔 연결에 HTTP 응답을 실어 전달합니다.
    - 2.청크 인코딩 방식을 사용해 끝나지 않는 HTTP 응답을 사용한다.
        - 메시지의 크기가 유동적일 때 사용하며, 응답 메시지의 끝에 크기가 0인 청크를 표시해 더 이상의 청크가 없음을 나타냅니다.
        - 이 방식을 역으로 생각하면, 청크 인코딩으로 전달 중인 응답은 크기가 0인 청크가 전달되지 않는 한 전체 응답이 종료된것이 아니란 의미입니다.
    - 3.비동기 처리
        - 서블릿 컨테이너 레벨에서는 외부에서 들어온 TCP연결을 관리하다가 응답 전용이라고 판단되는 연결에는 워크 스레드를 할당하지 않는 방법을 사용할 수 있습니다.
        - 이후 특정 연결에 청크 메시지를 전달할 때 관리하던 소켓 연결을 찾아내 직접 청크 메시지를 추가한다면 불필요한 스레드 블로킹을 피할 수 있습니다.

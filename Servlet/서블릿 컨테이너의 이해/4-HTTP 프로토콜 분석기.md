# 서블릿 컨테이너의 이해

## 2월 16일

### 4.HTTP 프로토콜 분석기

#### HTTP 프로토콜 메시지 분석
- 서블릿 컨테이너는 스트림을 사용해 Socket에서 한바이트씩 읽어들이면서 어느 시점에서 읽기를 중단하고 지금까지 받은 내용을 기반으로 요청 메시지를 구성할지 판단해야 합니다.
- HTTP 프로토콜에 대해 이런 상태를 분석하는 코드를 HTTP 상태 기계라고 합니다.

#### HTTP GET 요청 처리기
- HTTP 프로토콜을 설명하면서 HTTP 메시지는 CRLF로 행을 구분하고, 첫번째 행은 특별한 구조를 가지며, 빈 내용의 행이 나오기 전까지 콜론으로 구분되는 메시지 헤더가 존재한다고 언급한 바 있습니다.

#### 메시디 바디 처리 - Content-Length 인식
- 헤더에 Content-Length가 존재하고 사이즈가 0보다 크면 바디를 바이트 단위로 읽어 들여서 처리를 합니다.

#### 매개변수 처리 - 쿼리스트링과 x-www-form-urlencoded
- GET 방식의 경우 매개변수를 전달하면 요청 URL의 뒤에 ‘?’ 매개변수를 전달할 수 있습니다. 단, 해당 매개변수의 이름과 값은 ‘=‘로 분리하고 매개변수 쌍은 ‘&’로 구분합니다. 이런 방식을 쿼리스트링이라 합니다.
- 메시지 바디를 사용하는 x-www-form-urlencoded에 대한 처리는 좀 더 복잡합니다. 먼저 Content-Type 헤더 값을 확인하여 메시지 바디가 URL 인코딩된 값이란 것을 확인합니다. 그리고 메시지 바디를 ‘=‘와 ‘&’로 구분한 후 해당 값을 URLDecoder를 사용해 변환하여 paramMap을 구성합니다.

#### HTTP 프로토콜 메시지 분석 구현
- 구현의 기본적인 접근 방식은 다음과 같습니다.
- 먼저 소켓 스트림을 열어 클라인트가 전달한 데이터를 한 바이트씩 읽어갑니다.
- 이때 HTTP 메시지의 내부 상태를 계속 관찰하면서 메시지 종료 조건을 동적으로 판별해 메시지 읽기 종료 시점을 결정하고 HTTP 메시지를 구성합니다.
- 이제 웹 브라우저에서 받은 요청이 무엇인지 결정해 적절한 응답을 보냅니다. 
- 우리는 받은 HTTP 요청 내용을 파악할 수 있게 됐으므로 다음에는 해당 요청을 처리할 서블릿을 선택하고, 요청을 서블릿에게 위임을 합니다.

#### 성능 개선 - 버퍼의 사용
- 한 바이트씩 읽어 복사하는 것보다는 버퍼를 사용해 복제하는 것이 비교 할 수 없을 정도로 성능면에서 뛰어난 것을 확인할 수 있습니다.
- 또한 HTTP 메시지와 같이 네트워크상으로 접근되는 자원은 로컬 머신을 기원으로 하는자원과는 달리, 언제나 안정적으로 접근 가능할 것이라는 가정을 하기 힘듭니다.
- 이것은 원격 전송을 위해 물리적인 신호로 바뀌어 전달되는 동안 지연되거나 혹은 유실로 인한 전송 실패의 가능성이 높다는 점에 기인합니다.
- 따라서 이번 호출이 성공했다고 해서 다음 호출이 성공하리라는 보장은 없다는 것을 의미합니다.
- 또 획득 가능한 시점에 가능한 만큼 최대한 얻어오는 ‘게걸스런’ 방식을 사용하는 것에 대한 정당성을 뒷받침합니다.

#### 성능 개선 - 더 나은 I/O
- OS은 하드디스크나 마우스, 키보드, 프린터, 네트워크 카드, 메모리 등의 자원에 대해 전적인 제어권을 가집니다.
- 프로그래머는 OS가 허용한 시스템 호출함수를 사용해 해당 자원에 접근합니다. 다시 말해, 시스템 호출을 사용한다는 것은 OS에게 해당 작업에 대해 자기 대신 수행해 달라는 요청을 전달하는 것입니다.
- 이러한 위임 모델은 데이터가 OS 메모리 영역에 복제된 이후 프로스세에 전달됩니다.
- 다시 말해 하드웨어를 사용해 데이터를 획득하려고 시스템 호출 함수를 호출하면 OS는 필요한 데이터를 하드웨어에서 읽어들여 커널 영역에 복제하고 그 데이터를 다시 유저 영역에 전달합니다. 
- 그런데 DMA 지원이 가능한 버스는 미리 메모리 영역에 일부를 할당해 하드웨어상의 데이터를 메모리상의 DMA 영역으로 전달시킬 수 있습니다.
- 이때 DMA 영역에 접근할 수 있다면 커널영역에서 유저 영역으로의 복사를 줄일 수 있습니다.
- 이런 기능은 NIO로 통칭되는 java.nio 패키지를 사용해 구현하며, NIO와 전통적인 블로킹 IO는 다릅니다.



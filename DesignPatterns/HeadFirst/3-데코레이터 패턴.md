# Head First Design Patterns

## 07월 19일

### 3장 데코레이터 패턴

#### 개요
- 상속을 남용하는 전형적인 예를 살펴보자.
- 객체 작성이라는 형식으로 실행중에 클래스를 꾸미는 방법을 배워보자.
- 데코레이션 패턴을 배우고나면 원래 클래스의 코드는 전혀 바꾸지 않고도 자신이 만든 객체에 새로운 임무를 부여할 수 있다.

#### 스타버즈 커피 만들기
- 커피를 주문할 때 스팀, 우유, 두유, 모카 등 다양한 요소들을 추가 할 수 있다.
- 이러한 추가 요소(성능/기능)들을 새로 생길때마다 상속을 통하여 구현하는 맞을까? 
- 수퍼클래스의 상속을 통하여 공통이 부분을 수퍼클래스로 옮기는게 맞을까?

#### 서블클래스(상속)과 구성
- 서브클래스를 만드는 방식으로 행동을 상속 받으면 그 행동은 컴파일시에 완전히 결정된다.
- 게다가 모든 서브클래스에서 똑같은 행동을 상속 받아야합니다. 하지만 구성을 통해서 객체의 행동을 확장하면 실행중에 동적으로 행동을 설정할 수 있습니다.
- 구성을 이용하다면 수퍼클래스를 디자인했던 사람이 전혀 생각하지 못했던 것을 추가할 수도 있다. 클래스 코드를 전혀 건드리지 않고도 말이다.
- 구성을 이용하게 된다면 객체를 동적으로 구성하면, 기존 코드를 고치는 대신 새로운 코드를 만들어서 새로운 기능을 추가할 수 있다.

#### OCP - 클래스는 확장에 대해서는 열러 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.
- 기존 코드를 건드리지 않은채로 확장을 통해서 새로운 행동을 간단하게 추가할 수 있도록 해야한다.
- 코드에서 확장해야 할 부분을 선택할 때는 세심한 주의를 기울여야 한다.
- 무조건 OCP를 적용하는 것은 시간 낭비가 될 수도 있고, 괜히 쓸 데 없는 일을 하는 것일 수도 있다.
- 결과적으로 불필요하게 복잡하고 이해하기 힘든 코드만 만들게 되는 부작이 있을 수도 있으니 주의해야 한다.

#### 데코레이터 패턴
- 객체에 추가적인 요건을 동적으로 첨가한다.
- 데코레이터는 서브 클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.
- 행동은 기본 구성요소하고 다른 데코레이터 등을 인스턴스 변수에 저장하는 식으로 연결하게 된다.
- 구성을 활용하면 실행중에 데코레이터를 마음대로 조합해서 사용할 수 잇다는 장점이 있다.
- 데코레이터는 일반적으로 팩토리나 빌더 같은 다른 패턴을 써서 만들고 사용된다.(데코레이터 패턴 생성을 용이하게 관리하기 위해서)
- 데코레이터는 그 데코레이터가 감싸고 있는 객체에 행동을 추가하기 위한 용도로 만들어진다.

#### 자바의 데코레이터 패턴 - 자바 I/O
- FileInpuStream -> BufferedInpuStream -> LineNumberInpuStream

#### 데코레이터 패턴 단점
- 데코레이터 패턴을 이용해서 디자인을 하다 보면 잡다한 클래스들이 너무 많아진다.
- 그러다 보면 데코레이터를 기반으로 하는 API를 사용해야 하는 개발자 입장에서도 상당히 괴로워진다.
- 하지만 데코레이터가 어떤 식으로 작동하는지 이해하고 나면, 다른 사람이 데코레이터 패턴을 활용해서 만든 API를 쓰더라도 클래스들이 어떤 식으로 구성되어 있는지 일단 파악하고 나면 클래스를 데코레이터로 감싸서 원하는 행동을 구현할 수 있다.

# Head First Design Patterns

## 07월 23일

### 6장 커맨드 패턴

#### 개요
- 메소드 호출을 캡슐화한다.
- 메소드 호출을 캡슐화하면 계산 과정의 각 부분들을 결정화시킬 수 있기 때문에, 계산하는 코드를 호출한 객체에서는 어떤 식으로 일을 처리해야 하는지에 대해 전혀 신경쓰지 않아도 된다.
- 캡슐화된 메소드 호출을 로그 기록용으로 저장을 한다거나 취소 기능을 구현하기 위해 재사용하는 것과 같이 신기한 작업을 할 수도 있다.

#### 커맨드 패턴
- 커맨드 패턴은 이용하면 요구 사항을 객체로 캡슐화 할 수 있으면, 매개변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수도 있다.
- 또한 요청 내역을 큐에 저장하거나 로그로 기록할 수도 있으며, 작업취소 기능도 지원가능하다.
- 어떤 것을 요구하는 객체와 그 요구를 받아들이고 처리하는 객체를 분리시키는 객체지향 디자인 패턴의 한 모델이라고 볼 수 있다.
- 메타 커맨드 패턴을 이용하면 명령들로 이루어진 매크로를 만들어서 여러 개의 명령을 한 번에 실행할 수 있습니다.

#### 커맨드 객체
- 커맨드 객체는 특정 객체에 대한 특정 작업 요청을 캡슐화 시켜준다.
- 어떤 객체에 어떤 일을 시켜야 할지 잘 알고 있는 커맨드 객체만 있으면 된다.
- 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 쓴다.
- undo()메소드를 통하여 이전에 했던 작업을 기억하여 취소할 수 있다.

#### 식당에서의 커맨드 패턴
- 고객 - 클라이언트
- 주문서 - 커맨드
- 인보커 - 웨이트리스
- 리시버 - 주방장

#### 항상 리시버가 필요한가? 커맨드 객체에서 execute()를 구현해버리면 안되는가?
- 리시버에 있는 행동을 호출하는 더미 커맨드를 객체를 만드는게 일반적이다.
- 종종 스마트 커맨드를 만들어서 직접 처리하는 경우도 있다.
- 하지만 인보커와 리시버를 분리시키는 것이 불가해지고, 리시버를 이용해서 커맨드를 매개변수화시키는 것도 할 수 없다.

#### 작업취소를 할 때 히스토리 기능은 어떻게 구현할 수 있나?
- 실행한 커맨드를 스택에 집어넣으면 된다.

#### 매크로 커맨드 객체에서 직접 커맨드 객체의 execute() 메소드를 호출하면 안되는가?
- 커맨드를 동적으로 결정할 수 있다는 장점이 사라지게 된다.
- 일반적으로 커맨드리스트를 가지고 있는 커맨드를 구현해서 사용하는게 좀 더 우아한 방법이라고 할 수 있다.
- 추가해야 할 코드를 줄이는 데도 도움이 된다.

#### 커맨드 패턴 활용 - 작업 큐
- 커맨드를 이용하면 컴퓨테이션의 한 부분을 패키지로 묶어서 일급 객체 형태로 전달하는 것도 가능하다.
- 큐 한 쪽 끝은 커맨드를 추가할 수 있도록 되어 있고, 그 큐의 다른 쪽 끝에는 커맨드를 처리하기 위한 스레드들이 대기하고 있다.
- 각 스레드에서는 우선 execute() 메소드를 호출하고 그 호출이 완료되고 나면 커맨드 객체를 보내 버리고 새로운 커맨드 객체를 가져온다.
- 작업 큐 클래스는 컴퓨팅 작업을 하는 객체들과 완전히 분리되어 있음을 알 수 있다.
- 한 스레드에서 한동안 금융 관련 작업을 하다가 잠시 후에는 네트워크 작업을 처리할 수 있으니 말이다.

#### 커맨드 패턴 활용 - 로그에 기록
- 커맨드 패턴을 사용하면 store()와 load()라는 메소드를 추가하여 로그기능으로 사용할 수 있다.
- 로그를 이용하면 마지막 체크 포인트 이후로 한 모든 작업을 저장한 다음 시스템이 다운되었을 경우 기존 체크 포인트에 최근 수행된 작업을 다시 적용하는 방법을 쓸수 있다.
- 이런 테크닉을 확장해서 일련의 작업들에 대해서 트랜잭션을 활용하여 모든 작업이 완벽하게 처리되도록 하거나, 그렇지 않으면 아무 것도 처리되지 않게 롤백하도록 할 수 있다.


 



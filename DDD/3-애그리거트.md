# DDD(DDD START!)

## 5월 10일

### 3.애그리거트

#### 애그리거트
- 온라인 쇼핑몰을 위한 시스템을 개발한다면 아래와 같이 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는 데 도움이 된다.
![aggregate](/DDD/img/애그리거트.png)
- 그림을 보면 주문은 회원, 상품, 결제와 관련이 있다는 것을 쉽게 파악할 수 있다.
- 백 개 이상의 테이블을 한 장의 ERD에 모두 표시하면 개별 테이블 간의 관계를 파악하느라 큰 틀에서 데이터 구조를 이해하는 데 어려움을 겪게 되는 것처럼, 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
- 관계를 파악하기 어렵다는 것은 곧 코드를 변경하고 확장하는 것이 어려워진다는 것
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요, 그 방법이 바로 애그리거트다.
- 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 된다.
- 복잡한 도메인 을 단순한 구조로 만들어 준다.
- 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
- 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.
- 애그리거트는 다른 애그리커트에 속하지 않는다. 독립된 객체군이다.
- ex) 
    - 좋은 예
        - 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 생성되므로 이들은 한 애그리거트에 속한다.
    - 잘못된 예
        - 상품과 리뷰, 상품 엔티티와 리뷰 엔티티는 함께 생성되지 않고 함께 변경 되지도 않는다.

#### 애그리거트 루트
- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안 된다.
- 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- 애그리거트 전체를 관리 할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다.

#### 도메인 규칙과 일관성
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
- 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- ex)주문 애그리거트는 배송지 변경, 상품 변경,과 같은 기능을 제공하는데 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공한다.
- 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 두가지를 습관적으로 적용해야 한다.
    - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
    - 벨류 타입은 불변으로 구현한다.
- Set 메서드를 공개(public)으로 하게 된다면
    - 로직이 한곳에 응집되어 있지 않게 되므로 코드를 유지보수할 때에도 분석하고 수정하는 데 많은 시간을 들이게 된다.
- 밸류는 불변 타입으로 구현한다.
    - 밸류 객체의 값을 변경할 수 없으면 애그리거트 루트에서 밸류 객체를 구해도 값을 변경할 수 없기 때문에 애그리거트 외부에서 밸류 객체의 상태를 변경할 수 없게 된다.
    - 벨류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다.

#### 애그리거트 루트의 기능 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
- 기능 실행을 위임하기도 한다.

#### 트랜잭션 범위
- 트랜잭션 범위는 작을수록 좋다.
- 한 트랜잭션이 한 개 테이블 수정 것과 세개의 테이블을 수정하는 것은 성능에서 차이가 발생한다.
- 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 뜻하고 이는 전체적인 성능을 떨어뜨린다.
- 한 트랜잭션에는 한 개의 애그리거트만 수정해야 한다.
- 한번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어진다.
- 애그리거트는 서로 최대한 독립적이어야 하는데 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아지게 된다.
- 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야한다.
- 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려 할 수 있는 경우
    - 팀표준
        - 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우
    - 기술제약
        - 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데, 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야한다.
    - UI 구현의 편리
        - 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여루 주문 애그리거트의 상태를 변경할 수 있을. 것이다.

#### 리포지토리
- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- ex) Order와 OrderLine을 물리적으로 각각 별도의 DB 테이블에 저장한다고 해서 Order와 OrderLine을 위한 리포지토리를 각각 만들지 않는다. 애그리거트 루트인 Order를 위한 리포지토리만 존재 한다
- 새로운 애그리거트를 만들면 리포지토리에 적어도 두개의 메서드가 존재해야한다
    - save:애그리거트 저장
    - findById:ID로 애그리거트를 구함
    - 필요에 따라서 삭제, 검색등을 추가 할 수 있다
- 어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
- ex)Order 애그리거트와 관련된 테이블이 세 개라면 리포지터리를 통해서 Order 애그리거트를 저장할 때 애그리거트 루트와 매핑되는 테이블뿐만 아니라 애그리거트에 속한 모든 구성요소를 위한 테이블에 데이터를 저장해야 한다.
- 검색시에도 애그리거트에 속한 모든 구성요소를 들고 와야한다. 들고 오지 못 할 경우는 NullPointerException을 발생 시킨다.

#### ID를 이용한 애그리거트 참조
- 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.
- ex)JPA -> @ManyToOne, @OneToOne
- ORM 기술 덕에 애그리거트 루트에 대한 참조를 쉽게 구현 할 수 있고, 필드(또는 get메서드)를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 데이터를 객체 탐색을 통해 조회할 수 있다.
- 필드를 이용한 애그리거트 참조는 다음의 문제를 야기할 수 있다.
    - 편한 탐색 오용
    - 성능에 대한 고민
    - 확장 어려움
- 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.
- 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.
- 애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야 한다
- ex)JPA -> 지연로딩, 즉시로딩(불필요한 객체 조회, N+1등)
- 다양한 DBMS를 사용하게 될 경우 확장이 어려워 질 수도 있다.
- 해결방법
    - 다른 애그리거트를 참조할 때 ID 탐조를 사용하자
    - 단, 애그리거트 내의 엔티티를 참조할 때는 객체 레퍼런스로 참조하자
    - ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
    - 응집도를 높이고 결합도를 낮출수 있다.

#### ID를 이용한 참조와 조회 성능
- 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽어야 할 때 조회 속도가 문제될 수 있다.
- ex) JPA -> N+1 성능 문제
- 해결방법
    - 별도의 DAO를 만들고 DAO의 조회 메서드에서 세타 조인을 이용해서 한 번의 쿼리로 필요한 데이터를 로딩하면 된다.
- 애그리거트마다 서로 다른 저장소를 사용하는 경우에는 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.
- 이런 경우는 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다.

#### 애그리거트 간 집합 연관
- 애그리거트 간 1:N과 M:N
- 개념적으로 존재하는 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과 상관없는 경우가 종종 있다.
- ex)1:N -> 특정 카테고리에 잇는 상품 목록을 보여주는 요구사항에서 페이징 기능을 추가 할 경우
- M:N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다
- 상품이 여러 카테고리에 속할 수 있다면 M:N관계 성립한다.
- M:N을 양방향으로 할지 단방향으로 할지 제공할 기능에 맞게 구현하자(JPA)

#### 애그리거트를 팩토리로 사용하기
- 응용서비스단에 도메인을 위한 로직을 넣지 말자
- 도메인을 위한 로직은 도메인에서 처리하여 응집도를 높이고 결합도를 낮추자
- 도메인 기능을 넣기 위한 별도의 도메인 서비스나 팩토리 클래스를 만들어 처리하자
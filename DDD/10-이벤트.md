# DDD(DDD START!)

## 11월 28일

### 10.이벤트
#### 시스템 간 강결합의 문제
- 첫번째 문제, 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야 할지 애매하다
    - 반드시 트랜잭션을 이용하여 롤백 처리를 해줘야 할까?
- 두번째 문제, 외부 서비스의 걸리는 시간이 길어지면 그만큼 대기시간이 발생(성능)

#### 이벤트 개요
- 이벤트
- 이벤트 디스패처
- 이벤트 핸들러
- 이벤트 생성 주체
- 이벤트의 구성
    - 이벤트 종류
    - 이벤트 발생 시간
    - 추가 데이터

#### 이벤트 용도
- 첫번째, 도메인의 상태가 바뀔 때 다른 후처리를 해야 할 경우 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.(트리거)
- 두번째, 서로 다른 시스템 간의 데이터 동기화

#### 이벤트 장점
- 이벤트 핸들러를 사용하면 기능 확장에 용이하다.
- 서로 다른 도메인 로직이 섞있는걸 방지할 수 있다.

#### 이벤트 클래스
- 최소한의 데이터를 포함
- 이벤트 자체를 위한 상위 타입은 존재하지 않는다.

#### EventHandler 인터페이스
- 이벤트 핸들러를 위한 상위 인터페이스다.
- handle(), canHandle()

#### 이벤트 디스패처인 Events 구현
- 도메인을 사용하는 응용 서비스는 이벤트를 받아 처리할 핸들러를 Events.handle()로 등록하고, 도메인 기능을 실행한다.
- Events는 내부적으로 핸들러 목록을 유지하기 위해 ThreadLocal을 사용한다.
    - 웹 어플리케이션 서버는 쓰레드를 재사용하기 때문에 ThreadLocal을 관리해줘야한다.

#### 흐름 정리
- 1.이벤트 처리에 필요한 이벤트 핸들러를 생성한다.
- 2.이벤트 발생 전에 이벤트 핸들러를 Events.handle() 메서드를 이용해서 등록한다.
- 3.이벤트를 발생하는 도메인 기능을 실행한다.
- 4.도메인은 Events.raise()를 이용해서 이벤트를 발생한다.
- 5.Events.raise()는 등록된 핸들러의 canHandle()을 이용해서 이벤트를 처리할 수 있는지 확인한다.
- 6.핸들러가 이벤트를 처리할 수있다면 handle() 메서드를 이용해서 이벤트를 처리한다.
- 7.Events.raise() 실행을 끝내고 리턴한다.
- 8.도메인 기능 실행을 끝내고 리턴한다.
- 9.Events.reset()을 이용해서 ThreadLocal을 초기화한다.

#### AOP를 이용한 Events.reset() 실행
- Events.reset()을 AOP를 통하여 중복 코드 삭제

#### 동기 이벤트 처리
- 외부 서비스에 영향을 받는 문제를 해결하자.

#### 비동기 이벤트 처리
- 로컬 핸들러를 비동기로 실행하기
- 메시지 큐를 이용하기
- 이벤트 저장소와 이벤트 포워드 사용하기
- 이벤트 저장소와 이벤트 제공 API 사용하기

#### 로컬 핸들러를 비동기로 실행하기
- 이벤트 핸들러를 비동기로 실행하는 방법은 이벤트 핸들러를 별도 스레드로 실행하는 것이다.
- 별도 스레드를 이용해서 이벤트 핸들러를 실행하면 이벤트 발생 코드와 같은 트랜잭션 범위에 묶을 수 없기 때문에 한 트랜잭션으로 실행해야 하는 이벤트 핸들러는 비동기 처리해서는 안된다.

#### 메시징 시스템을 이용한 비동기 구현
- 비동기로 이벤트를 처리해야 할 때 사용하는 또 다른 방법은 RabbitMQ와 메시징 큐를 사용하는 것이다.
- 외부 시스템이기 때문에 글로벌 트랜잭션을 사용해야 한다.
    - 안전하게 이벤트를 메시지 큐에 전달할 수 있는 장점
    - 전체 성능이 떨어지는 단점
- 카프카는 글로벌 X, RabbitMQ는 글로벌 O

#### 이벤트 저장소를 이용한 비동기 처리
- 비동기로 이벤트를 처리하기 위한 또 다른 방법은 이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 것이다.
- 포워더 방식
    - 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더
- API 방식
    - 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억

#### 이벤트 적용 시 추가 고려사항
- 1.이벤트 소스를 EventEntiry에 추가할지 여부
- 2.포워더에서 전송 실패를 얼마나 허용할 것이냐에 대한 것
- 3.이벤트 손실에 대한것
    - 이벤트 저장소를 사용하는 방식은 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장
    - 로컬 핸들러를 이용해서 이벤트를 비동기로 철할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다.
- 4.이벤트 순서에 대한 것
    - 이벤트 저장소 방식은 순서를 보장할 수 있다.
    - 메시징 시스템은 사용 기술에 따라 이벤트 발생순서와 메시지 전달 순서가 다를 수 있다.
- 5.이벤트 재처리에 대한 것
    - 동일한 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할지 결정해야 한다.

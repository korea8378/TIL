# DDD(DDD START!)

## 5월 5일

### 1.도메인 모델 시작

#### 도메인
- ex)온라인 서점
- 개발자 입장에서 온라인 서점은 구현해야 할 소프트웨어의 대상이다.
- 온라인 서점 소프트웨어는 온라인으로 책을 판매하는 데 필요한 상품조회, 구매, 결제, 배송 추적등의 기능을 제공해야한다.
- 이때, 온라인 서점은 소프트웨어로 해결하고자 하는 문제 영역, 즉 도메인에 해당한다.
- 한 도메인은 다시 하위 도메인으로 나눌 수 있다. 예를 들어, 온라인 서점 도메인은
    - 주문, 회원, 혜택, 결제, 배송, 정산, 카탈로그 리뷰등
    - 카탈로그 하위 도메인
        - 고객에게 구매할 수 있는 상품 목록을 제공
    - 주문 하위 도메인
        - 고객의 주문을 처리
    - 혜택 하위 도메인
        - 쿠폰이나 특별 할인과 같은 서비스를 제공
    - 배송 하위 도메인
        - 고객에게 구매한 상품을 전달하는 일련의 과정을 처리
- 한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공
    - 고객이 물건을 구매하면 주문, 결제, 배송, 혜택 하위 도메인의 기능이 엮이게 된다.
- 특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야 할 모든 기능을 구현하는 것은 아니다.
    - 배송 도메인(외부 업체를 이용하여 처리하는 경우도 있다) 
도메인 모델
- 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.
- 도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델이다.
- 도메인 모델이란 용어는 도메인 자체를 표현하는 개념적인 모델을 의미하지만, 도메인 계층을 구현할 때 사용하는 객체 모델을 언급할 때에도 도메인 모델이란 용어를 사용한다.
- ex) 주문 도메인
    - 온라인 쇼핑몰에서 주문을 하려면 상품을 몇 개 살지 선택하고 배송지를 입력한다.
    - 선택한 상품 가격을 이용해서 총 지불 금액을 계산하고 금액 지불을 위한 결졔 수단을 선택한다.
    - 주문한 뒤에도 배송 전이면 배송지 주소를 변경하거나 주문을 취소 할 수 있다.
- 객체 기반 도메인 모델, 상태 다이어그램을 이용한 도메인 모델

#### 도메인 모델 패턴
- 어플리케이션 아키텍쳐

|계층|설명| 
|---|---| 
|사용자인터페이스 또는 표현|사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사요자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템도 사용자가 될 수 있다.|
|응용|사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인계층을 조합해서 기능을 실핸한다.|
|도메인|시스템이 제공할 도메인의 규칙을 구현한다.|
|인프라스트럭쳐|데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.|

- 도메인을 이용하여 객체지향으로 표현하는 것이 도메인 모델

#### 개념 모델과 구현 모델
- 개념 모델 
    - 순수하게 문제를 분석한 결과물이다.
    - 데이터베이스, 트랜잭션 처리, 성능, 구현 기술과 같은 것들은 고려하고 있지 않기 때문에 실제 코드를 작성할 때 개념 모델을 있는 그대로 사용 할 수 없다.
    - 그래서 개념 모델은 구현 가능한 형태의 모델로 전환하는 과정을 거친다.
    - 처음부터 완벽하게 만들 수 없다.
- 구현 모델
    - 개념모델을 기반으로 구현을 한 모델
    - 프로젝트 초기에는 개요 수준의 개념 모델로 도메인에 대한 전체 윤곽을 이해하는 데 집중하고
    - 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야한다.

#### 도메인 모델 도출
- 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들자
- 화이트보드, 종이와 연필, 모델링 툴 중 무엇을 선택하든지 간에 구현을 시작하려는 도메인에 대한 초기 모델이 필요하다.
- 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 구칙, 기능을 찾는 것이다.
- 이과정은 요구사항에서 출발한다.
- ex) 주문 도메인과 관련된 몇가지 요구사항
    - 최소 한 종류 이상의 상품을 주문해야한다
    - 한 상품을 한 개 이상 주문할 수 있다.
    - 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
    - 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱합 값이다.
    - 주문할 때 배송지 정보를 반드시 지정해야 한다.
    - 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
    - 출고를 하면 배송지 정보를 변경할 수 없다.
    - 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.
- 위의 요구사항에서 알 수 있는 것은 주문은
    - 출고 상태로 변경하기
    - 배송지 정보 변경하기
    - 주문 취소하기
    - 결제 완료로 변경하기
- 네 기능을 제공한다는 것이다.
- 요구사항을 통하여 어떤 데이터를 구성되는지 알 수 있다.
    - 한 상품을 한 개 이상 주문할 수 있다.
    - 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- 구매 개수, 상품의 가격, 주문할 상품, 총 가격이라는 데이터가 필요 하다는 것을 알 수 있다.

#### 엔티티와 벨류
- 도출한 모델은 크게 엔티티(Entity)와 밸류(Value)로 구분할 수 있다.
- 엔티티와 벨류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에
- 이 둘의 차이를 명학하게 이해하는 것은 도메인을 구현하는데 있어 중요하다.

#### 엔티티
- 엔티티의 가장 큰 특징은 식별자를 갖는다는 것이다.
- 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 갖는다.
- ex) 주문 도메인
    - 각 주문은 주문번호를 갖는데 이 주문번호는 각 주문마다 서로 다르다.
    - 따라서, 주문번호가 주문의 식별자가 된다.
    - 주무 도메인의 order가 엔티티가 되며 주문번호를 속성으로 갖게된다.
- 엔티티를 생성하고 엔티티의 속성을 바꾸고 엔티티를 삭제할 때까지 식별자는 유지된다.
- 엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티의 객체의 실벽자가 같으면 두 엔티티는 같다고 판단할 수 있다.

#### 엔티티 식별자 생성
- 엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라진다.
    - 특정 규칙에 따라 생성
    - UUID 사용
    - 값을 직접 입력
    - 일련번호 사용(시퀀스나 DB의 자동 증가 칼럼 사용)
- 레파지토리(repository) : 도메인 객체를 데이터베이스에 저장할 때 사용하는 구성요소이다.

#### 벨류
- 벨류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다.
<pre><code>
//변경 전
public class ShippingInfo {

	private String receiverName;
	private String receivePhoneNumber;
	//받는 사람

	private String shippingAddress1;
	private String shippingAddress2;
	private String shippingZipcode;
	//주소
}


//변경 후
public class ShippingInfo {
	private Receiver receiver;
	private Address address;
}

public class Receiver {
	private String receiverName;
	private String phoneNumber
}//벨류 타입

Public class Address {
	private String address1;
	private String address2;
	private String zipcode;
}//벨류 타입
</code></pre>
- 벨류 타입이 꼭 두개 이상의 데이터를 가져야 하는 것은 아니다.
- 벨류 타입을 사용함으로써 개념적으로 완전한 하나를 잘 표현 할 수 있는 것이다.(코드의 가독성)
- 벨류 타입을 위한 기능을 추가할 수 있다.
    - ex) Money라는 벨류 타입에 돈 계산을 위한 기능을 추가 할 수 있다.
- 벨류 객체의 데이터를 변경할 때는 기존 데이터를 변경 하기보다는 변경한 데이터를 갖는 새로운 벨류 객체를 생성하는 방식을 선호한다.
    - ex) Money(벨류 타입)가 가지고 있는 돈 계산 기능의 반환값을 새로운 Money 객체를 생성하여 반환
    - 데이터 변경 기능을 제공하지하지 않는 타입을 불변(immutable)이라고 표현한다.

#### 벨류 타입을 불변으로 구현 하는 이유
- 불변 타입을 사용하면 보다 안전한 코드를 작성할 수 있다
<pre><code>
Money price = new Money(1000);
OrderLine line = new OrderLine(product, price, quantity); =>[price=1000, quantity=2, amounts=2000]
price.setValue(2000); =>[price=2000, quantity=2, amounts=2000]

//해결법
public class OrderLine{
	…
	private Money price;

	public OrderLine(Product product, Money price, int quantity) {
		this.product = product;
		// Money가 불변 객체가 아니라면,
		// price 파라미터가 변경 될 때 발생하는 문제를 방지하기 위해
		// 데이터를 복사한 새로운 객체를 생성해야 한다.
		this.price = new Money(price.getValue());
		this.quantity = quantity;
		this.amounts = calculateAmouts();	
	}
}
</code></pre>

#### 엔티티 식별자와 벨류 타입
- 엔티티 식별자의 실제 데이터는 String과 같은 문자열로 구성된 경우가 많다.
    - ex) 신용카드번호, 이메일 등
- 엔티티 식별자를 벨류 타입으로 사용하면 가독성을 오른다.

#### 도메인 모델에 set 메서드 넣지 않기
- get/set 메서드는 습관적으로 추가하는 메서드이다.
- get/set 메서드를 무조건 추가하는 것은 좋지 않은 버릇이다.
- 특히 set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- 도메인 객체가 불완전한 상태로 사용 되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야한다.
- private을 이용하여 set메서드에 접근제한을 걸어 내부적으로 사용하게 할 수도 있다.
- 불변 벨류 타입을 사요하면 자연스럽게 벨류 타입에는 set 메서드를 구현하지 않는다.

#### 도메인 용어를 활용하자
<pre><code>
public enum OrderState {
	STEP1, STEP2, STEP3, STEP4, STEP5, STEP6	
}

public enum OrderState {
	PAYMENT_WATTING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED;
}
</code></pre>
- STEP1, STEP2, STEP3 보다는 하단의 각 도메인의 상태를 표현 해줄수 있는 enum이 좋게 보인다.
- 도메인 용어를 사용해서 최대한 도메인 규칙을 코드로 작성하게 되므로 버그도 줄어들게 된다.
- 알맞는 도메인 용어를 사용하자
- 도메인 용어에 알맞는 단어를 찾는 시간을 아까워하지 말자

#### 참조
- [순수함수](https://jeong-pro.tistory.com/23)
- [참조 투명성 예시](https://simsimjae.tistory.com/375)
- [[함수형 프로그래밍] 순수 함수, 참조 투명성](https://dowhateveryouwant.tistory.com/30)
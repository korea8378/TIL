# 2020-11-10 ~ 11

## 페이징 처리
- 페이징 성능 개선하기(No Offset) - https://jojoldu.tistory.com/528
- 페이징 성능 개선하기(커버링 인덱스) - https://jojoldu.tistory.com/529?category=637935
- 페이징 성능 개선하기(검색 버튼 사용시 페이지 건수 고정하기) - https://jojoldu.tistory.com/530?category=637935
- 페이징 성능 개선하기(첫 페이지 조회 결과 cache 하기) - https://jojoldu.tistory.com/531?category=637935

## 정리
- 페이징처리시에도 성능적으로 개선할 수 있다는 생각해본적이 없었다.
- jojoldu님은 글을 읽으면서 기존은 페이징 처리방식에서 벗어나 효율적으로 페이징 처리할 수 있는 방법들을 알게되었다.
- 기존의 페이징은 총 카운터를 해야하면 데이터 오프셋을 하나씩 일어나가는 방향으로 처리하게된다.
- 하지만 no offset을 이용한다면 페이징 처리 성능을 올리수 있다. no offset을 이용한다는것은 장점도 있지만 페이스북과 같이 페이징번호를 처리 하지않는 상황에서만 사용할 수 있다.
- no offset을 이용하지 못한다면 커버링 인덱스를 통하여 성능을 개선할수 있다. 커버링인덱스는 인덱스에 사용되는 컬럼이 select 모든 구절에 속해 있다는 조건이 필요하다.
- 그이유는 커버링인덱스는 인덱스 자체에 데이터들이 다포함되어 있기 때문에 데이터 블록에 접근을 하지 않고 인덱스로만 데이터를 처리한다.
- 또 다른 방법으로는 페이징 처리수 카운트하는 쿼리를 처음 검색 요청에는 처리하는 방법과 카운트수를 캐시하여 카운트 쿼리를 최대한 이용하지 않는 것이다.
- 카운트 쿼리를 뒤로 미루는 방식은 동적으로 UX를 한다는 조건이 있어야 하면 캐싱방법은 실시간으로 리스트의 아이템이들 변화가 많다면 캐시의 효율은 떨어지게 된다.
- 결론은 서비스에서 사용되는 리스트의 요구사항에 맞게 페이징 성능을 개선시켜보자.

